;;;; Auto-generated CFFI bindings for Sokol
;;;; DO NOT EDIT - generated by gen_lisp.py

(defpackage :sokol-gfx
  (:use :cl :cffi)
  (:nicknames :sg)
  (:export
   +-SG-BLENDFACTOR-DEFAULT+
   +-SG-BLENDFACTOR-FORCE-U32+
   +-SG-BLENDFACTOR-NUM+
   +-SG-BLENDOP-DEFAULT+
   +-SG-BLENDOP-FORCE-U32+
   +-SG-BLENDOP-NUM+
   +-SG-BORDERCOLOR-DEFAULT+
   +-SG-BORDERCOLOR-FORCE-U32+
   +-SG-BORDERCOLOR-NUM+
   +-SG-COLORMASK-DEFAULT+
   +-SG-COLORMASK-FORCE-U32+
   +-SG-COMPAREFUNC-DEFAULT+
   +-SG-COMPAREFUNC-FORCE-U32+
   +-SG-COMPAREFUNC-NUM+
   +-SG-CULLMODE-DEFAULT+
   +-SG-CULLMODE-FORCE-U32+
   +-SG-CULLMODE-NUM+
   +-SG-FACEWINDING-DEFAULT+
   +-SG-FACEWINDING-FORCE-U32+
   +-SG-FACEWINDING-NUM+
   +-SG-FILTER-DEFAULT+
   +-SG-FILTER-FORCE-U32+
   +-SG-FILTER-NUM+
   +-SG-IMAGESAMPLETYPE-DEFAULT+
   +-SG-IMAGESAMPLETYPE-FORCE-U32+
   +-SG-IMAGESAMPLETYPE-NUM+
   +-SG-IMAGETYPE-DEFAULT+
   +-SG-IMAGETYPE-FORCE-U32+
   +-SG-IMAGETYPE-NUM+
   +-SG-INDEXTYPE-DEFAULT+
   +-SG-INDEXTYPE-FORCE-U32+
   +-SG-INDEXTYPE-NUM+
   +-SG-LOADACTION-DEFAULT+
   +-SG-LOADACTION-FORCE-U32+
   +-SG-PIXELFORMAT-DEFAULT+
   +-SG-PIXELFORMAT-FORCE-U32+
   +-SG-PIXELFORMAT-NUM+
   +-SG-PRIMITIVETYPE-DEFAULT+
   +-SG-PRIMITIVETYPE-FORCE-U32+
   +-SG-PRIMITIVETYPE-NUM+
   +-SG-RESOURCESTATE-FORCE-U32+
   +-SG-SAMPLERTYPE-DEFAULT+
   +-SG-SAMPLERTYPE-FORCE-U32+
   +-SG-SAMPLERTYPE-NUM+
   +-SG-SHADERATTRBASETYPE-FORCE-U32+
   +-SG-SHADERSTAGE-FORCE-U32+
   +-SG-STENCILOP-DEFAULT+
   +-SG-STENCILOP-FORCE-U32+
   +-SG-STENCILOP-NUM+
   +-SG-STOREACTION-DEFAULT+
   +-SG-STOREACTION-FORCE-U32+
   +-SG-UNIFORMLAYOUT-DEFAULT+
   +-SG-UNIFORMLAYOUT-FORCE-U32+
   +-SG-UNIFORMLAYOUT-NUM+
   +-SG-UNIFORMTYPE-FORCE-U32+
   +-SG-UNIFORMTYPE-NUM+
   +-SG-VERTEXFORMAT-FORCE-U32+
   +-SG-VERTEXFORMAT-NUM+
   +-SG-VERTEXSTEP-DEFAULT+
   +-SG-VERTEXSTEP-FORCE-U32+
   +-SG-VERTEXSTEP-NUM+
   +-SG-VIEWTYPE-FORCE-U32+
   +-SG-WRAP-DEFAULT+
   +-SG-WRAP-FORCE-U32+
   +-SG-WRAP-NUM+
   +SG-BACKEND-D3D11+
   +SG-BACKEND-DUMMY+
   +SG-BACKEND-GLCORE+
   +SG-BACKEND-GLES3+
   +SG-BACKEND-METAL-IOS+
   +SG-BACKEND-METAL-MACOS+
   +SG-BACKEND-METAL-SIMULATOR+
   +SG-BACKEND-VULKAN+
   +SG-BACKEND-WGPU+
   +SG-BLENDFACTOR-BLEND-ALPHA+
   +SG-BLENDFACTOR-BLEND-COLOR+
   +SG-BLENDFACTOR-DST-ALPHA+
   +SG-BLENDFACTOR-DST-COLOR+
   +SG-BLENDFACTOR-ONE+
   +SG-BLENDFACTOR-ONE-MINUS-BLEND-ALPHA+
   +SG-BLENDFACTOR-ONE-MINUS-BLEND-COLOR+
   +SG-BLENDFACTOR-ONE-MINUS-DST-ALPHA+
   +SG-BLENDFACTOR-ONE-MINUS-DST-COLOR+
   +SG-BLENDFACTOR-ONE-MINUS-SRC-ALPHA+
   +SG-BLENDFACTOR-ONE-MINUS-SRC-COLOR+
   +SG-BLENDFACTOR-SRC-ALPHA+
   +SG-BLENDFACTOR-SRC-ALPHA-SATURATED+
   +SG-BLENDFACTOR-SRC-COLOR+
   +SG-BLENDFACTOR-ZERO+
   +SG-BLENDOP-ADD+
   +SG-BLENDOP-MAX+
   +SG-BLENDOP-MIN+
   +SG-BLENDOP-REVERSE-SUBTRACT+
   +SG-BLENDOP-SUBTRACT+
   +SG-BORDERCOLOR-OPAQUE-BLACK+
   +SG-BORDERCOLOR-OPAQUE-WHITE+
   +SG-BORDERCOLOR-TRANSPARENT-BLACK+
   +SG-COLORMASK-A+
   +SG-COLORMASK-B+
   +SG-COLORMASK-BA+
   +SG-COLORMASK-G+
   +SG-COLORMASK-GA+
   +SG-COLORMASK-GB+
   +SG-COLORMASK-GBA+
   +SG-COLORMASK-NONE+
   +SG-COLORMASK-R+
   +SG-COLORMASK-RA+
   +SG-COLORMASK-RB+
   +SG-COLORMASK-RBA+
   +SG-COLORMASK-RG+
   +SG-COLORMASK-RGA+
   +SG-COLORMASK-RGB+
   +SG-COLORMASK-RGBA+
   +SG-COMPAREFUNC-ALWAYS+
   +SG-COMPAREFUNC-EQUAL+
   +SG-COMPAREFUNC-GREATER+
   +SG-COMPAREFUNC-GREATER-EQUAL+
   +SG-COMPAREFUNC-LESS+
   +SG-COMPAREFUNC-LESS-EQUAL+
   +SG-COMPAREFUNC-NEVER+
   +SG-COMPAREFUNC-NOT-EQUAL+
   +SG-CULLMODE-BACK+
   +SG-CULLMODE-FRONT+
   +SG-CULLMODE-NONE+
   +SG-FACEWINDING-CCW+
   +SG-FACEWINDING-CW+
   +SG-FILTER-LINEAR+
   +SG-FILTER-NEAREST+
   +SG-IMAGESAMPLETYPE-DEPTH+
   +SG-IMAGESAMPLETYPE-FLOAT+
   +SG-IMAGESAMPLETYPE-SINT+
   +SG-IMAGESAMPLETYPE-UINT+
   +SG-IMAGESAMPLETYPE-UNFILTERABLE-FLOAT+
   +SG-IMAGETYPE-2D+
   +SG-IMAGETYPE-3D+
   +SG-IMAGETYPE-ARRAY+
   +SG-IMAGETYPE-CUBE+
   +SG-INDEXTYPE-NONE+
   +SG-INDEXTYPE-UINT16+
   +SG-INDEXTYPE-UINT32+
   +SG-LOADACTION-CLEAR+
   +SG-LOADACTION-DONTCARE+
   +SG-LOADACTION-LOAD+
   +SG-LOGITEM-BEGINPASS-ATTACHMENTS-ALIVE+
   +SG-LOGITEM-BEGINPASS-TOO-MANY-COLOR-ATTACHMENTS+
   +SG-LOGITEM-BEGINPASS-TOO-MANY-RESOLVE-ATTACHMENTS+
   +SG-LOGITEM-BUFFER-POOL-EXHAUSTED+
   +SG-LOGITEM-COMMIT-LISTENER-ARRAY-FULL+
   +SG-LOGITEM-D3D11-CREATE-2D-SRV-FAILED+
   +SG-LOGITEM-D3D11-CREATE-2D-TEXTURE-FAILED+
   +SG-LOGITEM-D3D11-CREATE-2D-TEXTURE-UNSUPPORTED-PIXEL-FORMAT+
   +SG-LOGITEM-D3D11-CREATE-3D-SRV-FAILED+
   +SG-LOGITEM-D3D11-CREATE-3D-TEXTURE-FAILED+
   +SG-LOGITEM-D3D11-CREATE-3D-TEXTURE-UNSUPPORTED-PIXEL-FORMAT+
   +SG-LOGITEM-D3D11-CREATE-BLEND-STATE-FAILED+
   +SG-LOGITEM-D3D11-CREATE-BUFFER-FAILED+
   +SG-LOGITEM-D3D11-CREATE-BUFFER-SRV-FAILED+
   +SG-LOGITEM-D3D11-CREATE-BUFFER-UAV-FAILED+
   +SG-LOGITEM-D3D11-CREATE-CONSTANT-BUFFER-FAILED+
   +SG-LOGITEM-D3D11-CREATE-DEPTH-STENCIL-STATE-FAILED+
   +SG-LOGITEM-D3D11-CREATE-DEPTH-TEXTURE-FAILED+
   +SG-LOGITEM-D3D11-CREATE-DEPTH-TEXTURE-UNSUPPORTED-PIXEL-FORMAT+
   +SG-LOGITEM-D3D11-CREATE-DSV-FAILED+
   +SG-LOGITEM-D3D11-CREATE-INPUT-LAYOUT-FAILED+
   +SG-LOGITEM-D3D11-CREATE-MSAA-TEXTURE-FAILED+
   +SG-LOGITEM-D3D11-CREATE-RASTERIZER-STATE-FAILED+
   +SG-LOGITEM-D3D11-CREATE-RTV-FAILED+
   +SG-LOGITEM-D3D11-CREATE-SAMPLER-STATE-FAILED+
   +SG-LOGITEM-D3D11-CREATE-UAV-FAILED+
   +SG-LOGITEM-D3D11-FEATURE-LEVEL-0-DETECTED+
   +SG-LOGITEM-D3D11-IMAGE-HLSL-REGISTER-T-OUT-OF-RANGE+
   +SG-LOGITEM-D3D11-LOAD-D3DCOMPILER-47-DLL-FAILED+
   +SG-LOGITEM-D3D11-MAP-FOR-APPEND-BUFFER-FAILED+
   +SG-LOGITEM-D3D11-MAP-FOR-UPDATE-BUFFER-FAILED+
   +SG-LOGITEM-D3D11-MAP-FOR-UPDATE-IMAGE-FAILED+
   +SG-LOGITEM-D3D11-SAMPLER-HLSL-REGISTER-S-OUT-OF-RANGE+
   +SG-LOGITEM-D3D11-SHADER-COMPILATION-FAILED+
   +SG-LOGITEM-D3D11-SHADER-COMPILATION-OUTPUT+
   +SG-LOGITEM-D3D11-STORAGEBUFFER-HLSL-REGISTER-T-OUT-OF-RANGE+
   +SG-LOGITEM-D3D11-STORAGEBUFFER-HLSL-REGISTER-U-OUT-OF-RANGE+
   +SG-LOGITEM-D3D11-STORAGEIMAGE-HLSL-REGISTER-U-OUT-OF-RANGE+
   +SG-LOGITEM-D3D11-UNIFORMBLOCK-HLSL-REGISTER-B-OUT-OF-RANGE+
   +SG-LOGITEM-DEALLOC-BUFFER-INVALID-STATE+
   +SG-LOGITEM-DEALLOC-IMAGE-INVALID-STATE+
   +SG-LOGITEM-DEALLOC-PIPELINE-INVALID-STATE+
   +SG-LOGITEM-DEALLOC-SAMPLER-INVALID-STATE+
   +SG-LOGITEM-DEALLOC-SHADER-INVALID-STATE+
   +SG-LOGITEM-DEALLOC-VIEW-INVALID-STATE+
   +SG-LOGITEM-DRAW-WITHOUT-BINDINGS+
   +SG-LOGITEM-FAIL-BUFFER-INVALID-STATE+
   +SG-LOGITEM-FAIL-IMAGE-INVALID-STATE+
   +SG-LOGITEM-FAIL-PIPELINE-INVALID-STATE+
   +SG-LOGITEM-FAIL-SAMPLER-INVALID-STATE+
   +SG-LOGITEM-FAIL-SHADER-INVALID-STATE+
   +SG-LOGITEM-FAIL-VIEW-INVALID-STATE+
   +SG-LOGITEM-GL-3D-TEXTURES-NOT-SUPPORTED+
   +SG-LOGITEM-GL-ARRAY-TEXTURES-NOT-SUPPORTED+
   +SG-LOGITEM-GL-FRAMEBUFFER-STATUS-INCOMPLETE-ATTACHMENT+
   +SG-LOGITEM-GL-FRAMEBUFFER-STATUS-INCOMPLETE-MISSING-ATTACHMENT+
   +SG-LOGITEM-GL-FRAMEBUFFER-STATUS-INCOMPLETE-MULTISAMPLE+
   +SG-LOGITEM-GL-FRAMEBUFFER-STATUS-UNDEFINED+
   +SG-LOGITEM-GL-FRAMEBUFFER-STATUS-UNKNOWN+
   +SG-LOGITEM-GL-FRAMEBUFFER-STATUS-UNSUPPORTED+
   +SG-LOGITEM-GL-IMAGE-SAMPLER-NAME-NOT-FOUND-IN-SHADER+
   +SG-LOGITEM-GL-SHADER-COMPILATION-FAILED+
   +SG-LOGITEM-GL-SHADER-LINKING-FAILED+
   +SG-LOGITEM-GL-STORAGEBUFFER-GLSL-BINDING-OUT-OF-RANGE+
   +SG-LOGITEM-GL-STORAGEIMAGE-GLSL-BINDING-OUT-OF-RANGE+
   +SG-LOGITEM-GL-TEXTURE-FORMAT-NOT-SUPPORTED+
   +SG-LOGITEM-GL-UNIFORMBLOCK-NAME-NOT-FOUND-IN-SHADER+
   +SG-LOGITEM-GL-VERTEX-ATTRIBUTE-NOT-FOUND-IN-SHADER+
   +SG-LOGITEM-IDENTICAL-COMMIT-LISTENER+
   +SG-LOGITEM-IMAGE-POOL-EXHAUSTED+
   +SG-LOGITEM-INIT-BUFFER-INVALID-STATE+
   +SG-LOGITEM-INIT-IMAGE-INVALID-STATE+
   +SG-LOGITEM-INIT-PIPELINE-INVALID-STATE+
   +SG-LOGITEM-INIT-SAMPLER-INVALID-STATE+
   +SG-LOGITEM-INIT-SHADER-INVALID-STATE+
   +SG-LOGITEM-INIT-VIEW-INVALID-STATE+
   +SG-LOGITEM-MALLOC-FAILED+
   +SG-LOGITEM-METAL-CREATE-BUFFER-FAILED+
   +SG-LOGITEM-METAL-CREATE-CPS-FAILED+
   +SG-LOGITEM-METAL-CREATE-CPS-OUTPUT+
   +SG-LOGITEM-METAL-CREATE-DSS-FAILED+
   +SG-LOGITEM-METAL-CREATE-RPS-FAILED+
   +SG-LOGITEM-METAL-CREATE-RPS-OUTPUT+
   +SG-LOGITEM-METAL-CREATE-SAMPLER-FAILED+
   +SG-LOGITEM-METAL-CREATE-TEXTURE-FAILED+
   +SG-LOGITEM-METAL-IMAGE-MSL-TEXTURE-SLOT-OUT-OF-RANGE+
   +SG-LOGITEM-METAL-SAMPLER-MSL-SAMPLER-SLOT-OUT-OF-RANGE+
   +SG-LOGITEM-METAL-SHADER-COMPILATION-FAILED+
   +SG-LOGITEM-METAL-SHADER-COMPILATION-OUTPUT+
   +SG-LOGITEM-METAL-SHADER-CREATION-FAILED+
   +SG-LOGITEM-METAL-SHADER-ENTRY-NOT-FOUND+
   +SG-LOGITEM-METAL-STORAGEBUFFER-MSL-BUFFER-SLOT-OUT-OF-RANGE+
   +SG-LOGITEM-METAL-STORAGEIMAGE-MSL-TEXTURE-SLOT-OUT-OF-RANGE+
   +SG-LOGITEM-METAL-TEXTURE-FORMAT-NOT-SUPPORTED+
   +SG-LOGITEM-METAL-UNIFORMBLOCK-MSL-BUFFER-SLOT-OUT-OF-RANGE+
   +SG-LOGITEM-OK+
   +SG-LOGITEM-PIPELINE-POOL-EXHAUSTED+
   +SG-LOGITEM-SAMPLER-POOL-EXHAUSTED+
   +SG-LOGITEM-SHADER-POOL-EXHAUSTED+
   +SG-LOGITEM-SHADERDESC-TOO-MANY-COMPUTESTAGE-STORAGEBUFFERS+
   +SG-LOGITEM-SHADERDESC-TOO-MANY-COMPUTESTAGE-STORAGEIMAGES+
   +SG-LOGITEM-SHADERDESC-TOO-MANY-COMPUTESTAGE-TEXTURES+
   +SG-LOGITEM-SHADERDESC-TOO-MANY-COMPUTESTAGE-TEXTURESAMPLERPAIRS+
   +SG-LOGITEM-SHADERDESC-TOO-MANY-FRAGMENTSTAGE-STORAGEBUFFERS+
   +SG-LOGITEM-SHADERDESC-TOO-MANY-FRAGMENTSTAGE-STORAGEIMAGES+
   +SG-LOGITEM-SHADERDESC-TOO-MANY-FRAGMENTSTAGE-TEXTURES+
   +SG-LOGITEM-SHADERDESC-TOO-MANY-FRAGMENTSTAGE-TEXTURESAMPLERPAIRS+
   +SG-LOGITEM-SHADERDESC-TOO-MANY-VERTEXSTAGE-STORAGEBUFFERS+
   +SG-LOGITEM-SHADERDESC-TOO-MANY-VERTEXSTAGE-STORAGEIMAGES+
   +SG-LOGITEM-SHADERDESC-TOO-MANY-VERTEXSTAGE-TEXTURES+
   +SG-LOGITEM-SHADERDESC-TOO-MANY-VERTEXSTAGE-TEXTURESAMPLERPAIRS+
   +SG-LOGITEM-TRACE-HOOKS-NOT-ENABLED+
   +SG-LOGITEM-UNINIT-BUFFER-INVALID-STATE+
   +SG-LOGITEM-UNINIT-IMAGE-INVALID-STATE+
   +SG-LOGITEM-UNINIT-PIPELINE-INVALID-STATE+
   +SG-LOGITEM-UNINIT-SAMPLER-INVALID-STATE+
   +SG-LOGITEM-UNINIT-SHADER-INVALID-STATE+
   +SG-LOGITEM-UNINIT-VIEW-INVALID-STATE+
   +SG-LOGITEM-VALIDATE-ABND-COMPUTE-EXPECTED-NO-IBUF+
   +SG-LOGITEM-VALIDATE-ABND-COMPUTE-EXPECTED-NO-VBUFS+
   +SG-LOGITEM-VALIDATE-ABND-EMPTY-BINDINGS+
   +SG-LOGITEM-VALIDATE-ABND-EXPECT-SBVIEW+
   +SG-LOGITEM-VALIDATE-ABND-EXPECT-SIMGVIEW+
   +SG-LOGITEM-VALIDATE-ABND-EXPECT-TEXVIEW+
   +SG-LOGITEM-VALIDATE-ABND-EXPECTED-IBUF+
   +SG-LOGITEM-VALIDATE-ABND-EXPECTED-NO-IBUF+
   +SG-LOGITEM-VALIDATE-ABND-EXPECTED-NONFILTERING-SAMPLER+
   +SG-LOGITEM-VALIDATE-ABND-EXPECTED-SAMPLER-BINDING+
   +SG-LOGITEM-VALIDATE-ABND-EXPECTED-SAMPLER-COMPARE-NEVER+
   +SG-LOGITEM-VALIDATE-ABND-EXPECTED-VBUF+
   +SG-LOGITEM-VALIDATE-ABND-EXPECTED-VIEW-BINDING+
   +SG-LOGITEM-VALIDATE-ABND-IBUF-ALIVE+
   +SG-LOGITEM-VALIDATE-ABND-IBUF-OVERFLOW+
   +SG-LOGITEM-VALIDATE-ABND-IBUF-USAGE+
   +SG-LOGITEM-VALIDATE-ABND-NO-PIPELINE+
   +SG-LOGITEM-VALIDATE-ABND-PASS-EXPECTED+
   +SG-LOGITEM-VALIDATE-ABND-PIPELINE-ALIVE+
   +SG-LOGITEM-VALIDATE-ABND-PIPELINE-SHADER-ALIVE+
   +SG-LOGITEM-VALIDATE-ABND-PIPELINE-SHADER-VALID+
   +SG-LOGITEM-VALIDATE-ABND-PIPELINE-VALID+
   +SG-LOGITEM-VALIDATE-ABND-SAMPLER-ALIVE+
   +SG-LOGITEM-VALIDATE-ABND-SAMPLER-VALID+
   +SG-LOGITEM-VALIDATE-ABND-SBVIEW-READWRITE-IMMUTABLE+
   +SG-LOGITEM-VALIDATE-ABND-SIMGVIEW-ACCESSFORMAT+
   +SG-LOGITEM-VALIDATE-ABND-SIMGVIEW-COMPUTE-PASS-EXPECTED+
   +SG-LOGITEM-VALIDATE-ABND-SIMGVIEW-IMAGETYPE-MISMATCH+
   +SG-LOGITEM-VALIDATE-ABND-TEXTURE-BINDING-VS-COLOR-ATTACHMENT+
   +SG-LOGITEM-VALIDATE-ABND-TEXTURE-BINDING-VS-DEPTHSTENCIL-ATTACHMENT+
   +SG-LOGITEM-VALIDATE-ABND-TEXTURE-BINDING-VS-RESOLVE-ATTACHMENT+
   +SG-LOGITEM-VALIDATE-ABND-TEXTURE-VS-STORAGEIMAGE-BINDING+
   +SG-LOGITEM-VALIDATE-ABND-TEXVIEW-EXPECTED-DEPTH-IMAGE+
   +SG-LOGITEM-VALIDATE-ABND-TEXVIEW-EXPECTED-FILTERABLE-IMAGE+
   +SG-LOGITEM-VALIDATE-ABND-TEXVIEW-EXPECTED-MULTISAMPLED-IMAGE+
   +SG-LOGITEM-VALIDATE-ABND-TEXVIEW-EXPECTED-NON-MULTISAMPLED-IMAGE+
   +SG-LOGITEM-VALIDATE-ABND-TEXVIEW-IMAGETYPE-MISMATCH+
   +SG-LOGITEM-VALIDATE-ABND-UNEXPECTED-SAMPLER-COMPARE-NEVER+
   +SG-LOGITEM-VALIDATE-ABND-VBUF-ALIVE+
   +SG-LOGITEM-VALIDATE-ABND-VBUF-OVERFLOW+
   +SG-LOGITEM-VALIDATE-ABND-VBUF-USAGE+
   +SG-LOGITEM-VALIDATE-ABND-VIEW-ALIVE+
   +SG-LOGITEM-VALIDATE-APIP-ATTACHMENT-SAMPLE-COUNT+
   +SG-LOGITEM-VALIDATE-APIP-ATTACHMENTS-ALIVE+
   +SG-LOGITEM-VALIDATE-APIP-COLORATTACHMENTS-COUNT+
   +SG-LOGITEM-VALIDATE-APIP-COLORATTACHMENTS-FORMAT+
   +SG-LOGITEM-VALIDATE-APIP-COLORATTACHMENTS-IMAGE-VALID+
   +SG-LOGITEM-VALIDATE-APIP-COLORATTACHMENTS-VIEW-VALID+
   +SG-LOGITEM-VALIDATE-APIP-COMPUTEPASS-EXPECTED+
   +SG-LOGITEM-VALIDATE-APIP-DEPTHSTENCILATTACHMENT-FORMAT+
   +SG-LOGITEM-VALIDATE-APIP-DEPTHSTENCILATTACHMENT-IMAGE-VALID+
   +SG-LOGITEM-VALIDATE-APIP-DEPTHSTENCILATTACHMENT-VIEW-VALID+
   +SG-LOGITEM-VALIDATE-APIP-PASS-EXPECTED+
   +SG-LOGITEM-VALIDATE-APIP-PIPELINE-EXISTS+
   +SG-LOGITEM-VALIDATE-APIP-PIPELINE-SHADER-ALIVE+
   +SG-LOGITEM-VALIDATE-APIP-PIPELINE-SHADER-VALID+
   +SG-LOGITEM-VALIDATE-APIP-PIPELINE-VALID+
   +SG-LOGITEM-VALIDATE-APIP-PIPELINE-VALID-ID+
   +SG-LOGITEM-VALIDATE-APIP-RENDERPASS-EXPECTED+
   +SG-LOGITEM-VALIDATE-APIP-SWAPCHAIN-COLOR-COUNT+
   +SG-LOGITEM-VALIDATE-APIP-SWAPCHAIN-COLOR-FORMAT+
   +SG-LOGITEM-VALIDATE-APIP-SWAPCHAIN-DEPTH-FORMAT+
   +SG-LOGITEM-VALIDATE-APIP-SWAPCHAIN-SAMPLE-COUNT+
   +SG-LOGITEM-VALIDATE-APPENDBUF-SIZE+
   +SG-LOGITEM-VALIDATE-APPENDBUF-UPDATE+
   +SG-LOGITEM-VALIDATE-APPENDBUF-USAGE+
   +SG-LOGITEM-VALIDATE-ASR-RENDERPASS-EXPECTED+
   +SG-LOGITEM-VALIDATE-AU-NO-PIPELINE+
   +SG-LOGITEM-VALIDATE-AU-NO-UNIFORMBLOCK-AT-SLOT+
   +SG-LOGITEM-VALIDATE-AU-PASS-EXPECTED+
   +SG-LOGITEM-VALIDATE-AU-PIPELINE-ALIVE+
   +SG-LOGITEM-VALIDATE-AU-PIPELINE-SHADER-ALIVE+
   +SG-LOGITEM-VALIDATE-AU-PIPELINE-SHADER-VALID+
   +SG-LOGITEM-VALIDATE-AU-PIPELINE-VALID+
   +SG-LOGITEM-VALIDATE-AU-SIZE+
   +SG-LOGITEM-VALIDATE-AVP-RENDERPASS-EXPECTED+
   +SG-LOGITEM-VALIDATE-BEGINPASS-ATTACHMENTS-EXPECTED+
   +SG-LOGITEM-VALIDATE-BEGINPASS-CANARY+
   +SG-LOGITEM-VALIDATE-BEGINPASS-COLORATTACHMENTVIEW-ALIVE+
   +SG-LOGITEM-VALIDATE-BEGINPASS-COLORATTACHMENTVIEW-IMAGE-ALIVE+
   +SG-LOGITEM-VALIDATE-BEGINPASS-COLORATTACHMENTVIEW-IMAGE-VALID+
   +SG-LOGITEM-VALIDATE-BEGINPASS-COLORATTACHMENTVIEW-SAMPLECOUNT+
   +SG-LOGITEM-VALIDATE-BEGINPASS-COLORATTACHMENTVIEW-SAMPLECOUNTS-EQUAL+
   +SG-LOGITEM-VALIDATE-BEGINPASS-COLORATTACHMENTVIEW-SIZES+
   +SG-LOGITEM-VALIDATE-BEGINPASS-COLORATTACHMENTVIEW-TYPE+
   +SG-LOGITEM-VALIDATE-BEGINPASS-COLORATTACHMENTVIEW-VALID+
   +SG-LOGITEM-VALIDATE-BEGINPASS-COLORATTACHMENTVIEWS-CONTINUOUS+
   +SG-LOGITEM-VALIDATE-BEGINPASS-COMPUTEPASS-EXPECT-NO-ATTACHMENTS+
   +SG-LOGITEM-VALIDATE-BEGINPASS-DEPTHSTENCILATTACHMENTVIEW-ALIVE+
   +SG-LOGITEM-VALIDATE-BEGINPASS-DEPTHSTENCILATTACHMENTVIEW-IMAGE-ALIVE+
   +SG-LOGITEM-VALIDATE-BEGINPASS-DEPTHSTENCILATTACHMENTVIEW-IMAGE-VALID+
   +SG-LOGITEM-VALIDATE-BEGINPASS-DEPTHSTENCILATTACHMENTVIEW-SAMPLECOUNT+
   +SG-LOGITEM-VALIDATE-BEGINPASS-DEPTHSTENCILATTACHMENTVIEW-SIZES+
   +SG-LOGITEM-VALIDATE-BEGINPASS-DEPTHSTENCILATTACHMENTVIEW-TYPE+
   +SG-LOGITEM-VALIDATE-BEGINPASS-DEPTHSTENCILATTACHMENTVIEW-VALID+
   +SG-LOGITEM-VALIDATE-BEGINPASS-DEPTHSTENCILATTACHMENTVIEWS-CONTINUOUS+
   +SG-LOGITEM-VALIDATE-BEGINPASS-RESOLVEATTACHMENTVIEW-ALIVE+
   +SG-LOGITEM-VALIDATE-BEGINPASS-RESOLVEATTACHMENTVIEW-IMAGE-ALIVE+
   +SG-LOGITEM-VALIDATE-BEGINPASS-RESOLVEATTACHMENTVIEW-IMAGE-VALID+
   +SG-LOGITEM-VALIDATE-BEGINPASS-RESOLVEATTACHMENTVIEW-NO-COLORATTACHMENTVIEW+
   +SG-LOGITEM-VALIDATE-BEGINPASS-RESOLVEATTACHMENTVIEW-SIZES+
   +SG-LOGITEM-VALIDATE-BEGINPASS-RESOLVEATTACHMENTVIEW-TYPE+
   +SG-LOGITEM-VALIDATE-BEGINPASS-RESOLVEATTACHMENTVIEW-VALID+
   +SG-LOGITEM-VALIDATE-BEGINPASS-SWAPCHAIN-D3D11-EXPECT-DEPTHSTENCILVIEW+
   +SG-LOGITEM-VALIDATE-BEGINPASS-SWAPCHAIN-D3D11-EXPECT-DEPTHSTENCILVIEW-NOTSET+
   +SG-LOGITEM-VALIDATE-BEGINPASS-SWAPCHAIN-D3D11-EXPECT-RENDERVIEW+
   +SG-LOGITEM-VALIDATE-BEGINPASS-SWAPCHAIN-D3D11-EXPECT-RENDERVIEW-NOTSET+
   +SG-LOGITEM-VALIDATE-BEGINPASS-SWAPCHAIN-D3D11-EXPECT-RESOLVEVIEW+
   +SG-LOGITEM-VALIDATE-BEGINPASS-SWAPCHAIN-D3D11-EXPECT-RESOLVEVIEW-NOTSET+
   +SG-LOGITEM-VALIDATE-BEGINPASS-SWAPCHAIN-EXPECT-COLORFORMAT+
   +SG-LOGITEM-VALIDATE-BEGINPASS-SWAPCHAIN-EXPECT-COLORFORMAT-NOTSET+
   +SG-LOGITEM-VALIDATE-BEGINPASS-SWAPCHAIN-EXPECT-DEPTHFORMAT-NOTSET+
   +SG-LOGITEM-VALIDATE-BEGINPASS-SWAPCHAIN-EXPECT-HEIGHT+
   +SG-LOGITEM-VALIDATE-BEGINPASS-SWAPCHAIN-EXPECT-HEIGHT-NOTSET+
   +SG-LOGITEM-VALIDATE-BEGINPASS-SWAPCHAIN-EXPECT-SAMPLECOUNT+
   +SG-LOGITEM-VALIDATE-BEGINPASS-SWAPCHAIN-EXPECT-SAMPLECOUNT-NOTSET+
   +SG-LOGITEM-VALIDATE-BEGINPASS-SWAPCHAIN-EXPECT-WIDTH+
   +SG-LOGITEM-VALIDATE-BEGINPASS-SWAPCHAIN-EXPECT-WIDTH-NOTSET+
   +SG-LOGITEM-VALIDATE-BEGINPASS-SWAPCHAIN-GL-EXPECT-FRAMEBUFFER-NOTSET+
   +SG-LOGITEM-VALIDATE-BEGINPASS-SWAPCHAIN-METAL-EXPECT-CURRENTDRAWABLE+
   +SG-LOGITEM-VALIDATE-BEGINPASS-SWAPCHAIN-METAL-EXPECT-CURRENTDRAWABLE-NOTSET+
   +SG-LOGITEM-VALIDATE-BEGINPASS-SWAPCHAIN-METAL-EXPECT-DEPTHSTENCILTEXTURE+
   +SG-LOGITEM-VALIDATE-BEGINPASS-SWAPCHAIN-METAL-EXPECT-DEPTHSTENCILTEXTURE-NOTSET+
   +SG-LOGITEM-VALIDATE-BEGINPASS-SWAPCHAIN-METAL-EXPECT-MSAACOLORTEXTURE+
   +SG-LOGITEM-VALIDATE-BEGINPASS-SWAPCHAIN-METAL-EXPECT-MSAACOLORTEXTURE-NOTSET+
   +SG-LOGITEM-VALIDATE-BEGINPASS-SWAPCHAIN-WGPU-EXPECT-DEPTHSTENCILVIEW+
   +SG-LOGITEM-VALIDATE-BEGINPASS-SWAPCHAIN-WGPU-EXPECT-DEPTHSTENCILVIEW-NOTSET+
   +SG-LOGITEM-VALIDATE-BEGINPASS-SWAPCHAIN-WGPU-EXPECT-RENDERVIEW+
   +SG-LOGITEM-VALIDATE-BEGINPASS-SWAPCHAIN-WGPU-EXPECT-RENDERVIEW-NOTSET+
   +SG-LOGITEM-VALIDATE-BEGINPASS-SWAPCHAIN-WGPU-EXPECT-RESOLVEVIEW+
   +SG-LOGITEM-VALIDATE-BEGINPASS-SWAPCHAIN-WGPU-EXPECT-RESOLVEVIEW-NOTSET+
   +SG-LOGITEM-VALIDATE-BUFFERDESC-CANARY+
   +SG-LOGITEM-VALIDATE-BUFFERDESC-EXPECT-DATA+
   +SG-LOGITEM-VALIDATE-BUFFERDESC-EXPECT-MATCHING-DATA-SIZE+
   +SG-LOGITEM-VALIDATE-BUFFERDESC-EXPECT-NO-DATA+
   +SG-LOGITEM-VALIDATE-BUFFERDESC-EXPECT-NONZERO-SIZE+
   +SG-LOGITEM-VALIDATE-BUFFERDESC-EXPECT-ZERO-DATA-SIZE+
   +SG-LOGITEM-VALIDATE-BUFFERDESC-IMMUTABLE-DYNAMIC-STREAM+
   +SG-LOGITEM-VALIDATE-BUFFERDESC-SEPARATE-BUFFER-TYPES+
   +SG-LOGITEM-VALIDATE-BUFFERDESC-STORAGEBUFFER-SIZE-MULTIPLE-4+
   +SG-LOGITEM-VALIDATE-BUFFERDESC-STORAGEBUFFER-SUPPORTED+
   +SG-LOGITEM-VALIDATE-DISPATCH-COMPUTEPASS-EXPECTED+
   +SG-LOGITEM-VALIDATE-DISPATCH-NUMGROUPSX+
   +SG-LOGITEM-VALIDATE-DISPATCH-NUMGROUPSY+
   +SG-LOGITEM-VALIDATE-DISPATCH-NUMGROUPSZ+
   +SG-LOGITEM-VALIDATE-DISPATCH-REQUIRED-BINDINGS-OR-UNIFORMS-MISSING+
   +SG-LOGITEM-VALIDATE-DRAW-BASEELEMENT-GE-ZERO+
   +SG-LOGITEM-VALIDATE-DRAW-EX-BASEELEMENT-GE-ZERO+
   +SG-LOGITEM-VALIDATE-DRAW-EX-BASEINSTANCE-GE-ZERO+
   +SG-LOGITEM-VALIDATE-DRAW-EX-BASEINSTANCE-NOT-SUPPORTED+
   +SG-LOGITEM-VALIDATE-DRAW-EX-BASEINSTANCE-VS-INSTANCED+
   +SG-LOGITEM-VALIDATE-DRAW-EX-BASEVERTEX-NOT-SUPPORTED+
   +SG-LOGITEM-VALIDATE-DRAW-EX-BASEVERTEX-VS-INDEXED+
   +SG-LOGITEM-VALIDATE-DRAW-EX-NUMELEMENTS-GE-ZERO+
   +SG-LOGITEM-VALIDATE-DRAW-EX-NUMINSTANCES-GE-ZERO+
   +SG-LOGITEM-VALIDATE-DRAW-EX-RENDERPASS-EXPECTED+
   +SG-LOGITEM-VALIDATE-DRAW-NUMELEMENTS-GE-ZERO+
   +SG-LOGITEM-VALIDATE-DRAW-NUMINSTANCES-GE-ZERO+
   +SG-LOGITEM-VALIDATE-DRAW-RENDERPASS-EXPECTED+
   +SG-LOGITEM-VALIDATE-DRAW-REQUIRED-BINDINGS-OR-UNIFORMS-MISSING+
   +SG-LOGITEM-VALIDATE-IMAGEDATA-DATA-SIZE+
   +SG-LOGITEM-VALIDATE-IMAGEDATA-NODATA+
   +SG-LOGITEM-VALIDATE-IMAGEDESC-ATTACHMENT-EXPECT-IMMUTABLE+
   +SG-LOGITEM-VALIDATE-IMAGEDESC-ATTACHMENT-EXPECT-NO-DATA+
   +SG-LOGITEM-VALIDATE-IMAGEDESC-ATTACHMENT-MSAA-3D-IMAGE+
   +SG-LOGITEM-VALIDATE-IMAGEDESC-ATTACHMENT-MSAA-ARRAY-IMAGE+
   +SG-LOGITEM-VALIDATE-IMAGEDESC-ATTACHMENT-MSAA-CUBE-IMAGE+
   +SG-LOGITEM-VALIDATE-IMAGEDESC-ATTACHMENT-MSAA-NUM-MIPMAPS+
   +SG-LOGITEM-VALIDATE-IMAGEDESC-ATTACHMENT-NO-MSAA-SUPPORT+
   +SG-LOGITEM-VALIDATE-IMAGEDESC-ATTACHMENT-PIXELFORMAT+
   +SG-LOGITEM-VALIDATE-IMAGEDESC-ATTACHMENT-RESOLVE-EXPECT-NO-MSAA+
   +SG-LOGITEM-VALIDATE-IMAGEDESC-CANARY+
   +SG-LOGITEM-VALIDATE-IMAGEDESC-COMPRESSED-IMMUTABLE+
   +SG-LOGITEM-VALIDATE-IMAGEDESC-DEPTH-3D-IMAGE+
   +SG-LOGITEM-VALIDATE-IMAGEDESC-DYNAMIC-NO-DATA+
   +SG-LOGITEM-VALIDATE-IMAGEDESC-HEIGHT+
   +SG-LOGITEM-VALIDATE-IMAGEDESC-IMAGETYPE-2D-NUMSLICES+
   +SG-LOGITEM-VALIDATE-IMAGEDESC-IMAGETYPE-3D-NUMSLICES+
   +SG-LOGITEM-VALIDATE-IMAGEDESC-IMAGETYPE-ARRAY-NUMSLICES+
   +SG-LOGITEM-VALIDATE-IMAGEDESC-IMAGETYPE-CUBE-NUMSLICES+
   +SG-LOGITEM-VALIDATE-IMAGEDESC-IMMUTABLE-DYNAMIC-STREAM+
   +SG-LOGITEM-VALIDATE-IMAGEDESC-INJECTED-NO-DATA+
   +SG-LOGITEM-VALIDATE-IMAGEDESC-MSAA-BUT-NO-ATTACHMENT+
   +SG-LOGITEM-VALIDATE-IMAGEDESC-NONRT-PIXELFORMAT+
   +SG-LOGITEM-VALIDATE-IMAGEDESC-NUMSLICES+
   +SG-LOGITEM-VALIDATE-IMAGEDESC-STORAGEIMAGE-EXPECT-NO-MSAA+
   +SG-LOGITEM-VALIDATE-IMAGEDESC-STORAGEIMAGE-PIXELFORMAT+
   +SG-LOGITEM-VALIDATE-IMAGEDESC-WIDTH+
   +SG-LOGITEM-VALIDATE-PIPELINEDESC-ATTR-BASETYPE-MISMATCH+
   +SG-LOGITEM-VALIDATE-PIPELINEDESC-ATTR-SEMANTICS+
   +SG-LOGITEM-VALIDATE-PIPELINEDESC-BLENDOP-MINMAX-REQUIRES-BLENDFACTOR-ONE+
   +SG-LOGITEM-VALIDATE-PIPELINEDESC-CANARY+
   +SG-LOGITEM-VALIDATE-PIPELINEDESC-COMPUTE-SHADER-EXPECTED+
   +SG-LOGITEM-VALIDATE-PIPELINEDESC-LAYOUT-STRIDE4+
   +SG-LOGITEM-VALIDATE-PIPELINEDESC-NO-COMPUTE-SHADER-EXPECTED+
   +SG-LOGITEM-VALIDATE-PIPELINEDESC-NO-CONT-ATTRS+
   +SG-LOGITEM-VALIDATE-PIPELINEDESC-SHADER+
   +SG-LOGITEM-VALIDATE-PIPELINEDESC-SHADER-READONLY-STORAGEBUFFERS+
   +SG-LOGITEM-VALIDATE-SAMPLERDESC-ANISTROPIC-REQUIRES-LINEAR-FILTERING+
   +SG-LOGITEM-VALIDATE-SAMPLERDESC-CANARY+
   +SG-LOGITEM-VALIDATE-SHADERDESC-ATTR-STRING-TOO-LONG+
   +SG-LOGITEM-VALIDATE-SHADERDESC-CANARY+
   +SG-LOGITEM-VALIDATE-SHADERDESC-COMPARISON-SAMPLER-REQUIRED+
   +SG-LOGITEM-VALIDATE-SHADERDESC-COMPUTE-SOURCE+
   +SG-LOGITEM-VALIDATE-SHADERDESC-COMPUTE-SOURCE-OR-BYTECODE+
   +SG-LOGITEM-VALIDATE-SHADERDESC-FRAGMENT-SOURCE+
   +SG-LOGITEM-VALIDATE-SHADERDESC-FRAGMENT-SOURCE-OR-BYTECODE+
   +SG-LOGITEM-VALIDATE-SHADERDESC-INVALID-SHADER-COMBO+
   +SG-LOGITEM-VALIDATE-SHADERDESC-METAL-THREADS-PER-THREADGROUP-INITIALIZED+
   +SG-LOGITEM-VALIDATE-SHADERDESC-METAL-THREADS-PER-THREADGROUP-MULTIPLE-32+
   +SG-LOGITEM-VALIDATE-SHADERDESC-NO-BYTECODE-SIZE+
   +SG-LOGITEM-VALIDATE-SHADERDESC-NONFILTERING-SAMPLER-REQUIRED+
   +SG-LOGITEM-VALIDATE-SHADERDESC-SAMPLER-HLSL-REGISTER-S-COLLISION+
   +SG-LOGITEM-VALIDATE-SHADERDESC-SAMPLER-METAL-SAMPLER-SLOT-COLLISION+
   +SG-LOGITEM-VALIDATE-SHADERDESC-SAMPLER-NOT-REFERENCED-BY-TEXTURE-SAMPLER-PAIRS+
   +SG-LOGITEM-VALIDATE-SHADERDESC-SAMPLER-SPIRV-SET1-BINDING-COLLISION+
   +SG-LOGITEM-VALIDATE-SHADERDESC-SAMPLER-WGSL-GROUP1-BINDING-COLLISION+
   +SG-LOGITEM-VALIDATE-SHADERDESC-TEXTURE-SAMPLER-PAIR-EXPECT-TEXTURE-VIEW+
   +SG-LOGITEM-VALIDATE-SHADERDESC-TEXTURE-SAMPLER-PAIR-GLSL-NAME+
   +SG-LOGITEM-VALIDATE-SHADERDESC-TEXTURE-SAMPLER-PAIR-SAMPLER-SLOT-OUT-OF-RANGE+
   +SG-LOGITEM-VALIDATE-SHADERDESC-TEXTURE-SAMPLER-PAIR-SAMPLER-STAGE-MISMATCH+
   +SG-LOGITEM-VALIDATE-SHADERDESC-TEXTURE-SAMPLER-PAIR-TEXTURE-STAGE-MISMATCH+
   +SG-LOGITEM-VALIDATE-SHADERDESC-TEXTURE-SAMPLER-PAIR-VIEW-SLOT-OUT-OF-RANGE+
   +SG-LOGITEM-VALIDATE-SHADERDESC-TEXVIEW-NOT-REFERENCED-BY-TEXTURE-SAMPLER-PAIRS+
   +SG-LOGITEM-VALIDATE-SHADERDESC-UNIFORMBLOCK-ARRAY-COUNT+
   +SG-LOGITEM-VALIDATE-SHADERDESC-UNIFORMBLOCK-HLSL-REGISTER-B-COLLISION+
   +SG-LOGITEM-VALIDATE-SHADERDESC-UNIFORMBLOCK-METAL-BUFFER-SLOT-COLLISION+
   +SG-LOGITEM-VALIDATE-SHADERDESC-UNIFORMBLOCK-NO-CONT-MEMBERS+
   +SG-LOGITEM-VALIDATE-SHADERDESC-UNIFORMBLOCK-NO-MEMBERS+
   +SG-LOGITEM-VALIDATE-SHADERDESC-UNIFORMBLOCK-SIZE-IS-ZERO+
   +SG-LOGITEM-VALIDATE-SHADERDESC-UNIFORMBLOCK-SIZE-MISMATCH+
   +SG-LOGITEM-VALIDATE-SHADERDESC-UNIFORMBLOCK-SPIRV-SET0-BINDING-COLLISION+
   +SG-LOGITEM-VALIDATE-SHADERDESC-UNIFORMBLOCK-STD140-ARRAY-TYPE+
   +SG-LOGITEM-VALIDATE-SHADERDESC-UNIFORMBLOCK-UNIFORM-GLSL-NAME+
   +SG-LOGITEM-VALIDATE-SHADERDESC-UNIFORMBLOCK-WGSL-GROUP0-BINDING-COLLISION+
   +SG-LOGITEM-VALIDATE-SHADERDESC-VERTEX-SOURCE+
   +SG-LOGITEM-VALIDATE-SHADERDESC-VERTEX-SOURCE-OR-BYTECODE+
   +SG-LOGITEM-VALIDATE-SHADERDESC-VIEW-STORAGEBUFFER-GLSL-BINDING-COLLISION+
   +SG-LOGITEM-VALIDATE-SHADERDESC-VIEW-STORAGEBUFFER-HLSL-REGISTER-T-COLLISION+
   +SG-LOGITEM-VALIDATE-SHADERDESC-VIEW-STORAGEBUFFER-HLSL-REGISTER-U-COLLISION+
   +SG-LOGITEM-VALIDATE-SHADERDESC-VIEW-STORAGEBUFFER-METAL-BUFFER-SLOT-COLLISION+
   +SG-LOGITEM-VALIDATE-SHADERDESC-VIEW-STORAGEBUFFER-SPIRV-SET1-BINDING-COLLISION+
   +SG-LOGITEM-VALIDATE-SHADERDESC-VIEW-STORAGEBUFFER-WGSL-GROUP1-BINDING-COLLISION+
   +SG-LOGITEM-VALIDATE-SHADERDESC-VIEW-STORAGEIMAGE-EXPECT-COMPUTE-STAGE+
   +SG-LOGITEM-VALIDATE-SHADERDESC-VIEW-STORAGEIMAGE-GLSL-BINDING-COLLISION+
   +SG-LOGITEM-VALIDATE-SHADERDESC-VIEW-STORAGEIMAGE-HLSL-REGISTER-U-COLLISION+
   +SG-LOGITEM-VALIDATE-SHADERDESC-VIEW-STORAGEIMAGE-METAL-TEXTURE-SLOT-COLLISION+
   +SG-LOGITEM-VALIDATE-SHADERDESC-VIEW-STORAGEIMAGE-SPIRV-SET1-BINDING-COLLISION+
   +SG-LOGITEM-VALIDATE-SHADERDESC-VIEW-STORAGEIMAGE-WGSL-GROUP1-BINDING-COLLISION+
   +SG-LOGITEM-VALIDATE-SHADERDESC-VIEW-TEXTURE-HLSL-REGISTER-T-COLLISION+
   +SG-LOGITEM-VALIDATE-SHADERDESC-VIEW-TEXTURE-METAL-TEXTURE-SLOT-COLLISION+
   +SG-LOGITEM-VALIDATE-SHADERDESC-VIEW-TEXTURE-SPIRV-SET1-BINDING-COLLISION+
   +SG-LOGITEM-VALIDATE-SHADERDESC-VIEW-TEXTURE-WGSL-GROUP1-BINDING-COLLISION+
   +SG-LOGITEM-VALIDATE-UPDATEBUF-APPEND+
   +SG-LOGITEM-VALIDATE-UPDATEBUF-ONCE+
   +SG-LOGITEM-VALIDATE-UPDATEBUF-SIZE+
   +SG-LOGITEM-VALIDATE-UPDATEBUF-USAGE+
   +SG-LOGITEM-VALIDATE-UPDIMG-ONCE+
   +SG-LOGITEM-VALIDATE-UPDIMG-USAGE+
   +SG-LOGITEM-VALIDATE-VIEWDESC-ANY-VIEWTYPE+
   +SG-LOGITEM-VALIDATE-VIEWDESC-CANARY+
   +SG-LOGITEM-VALIDATE-VIEWDESC-COLORATTACHMENT-PIXELFORMAT+
   +SG-LOGITEM-VALIDATE-VIEWDESC-COLORATTACHMENT-USAGE+
   +SG-LOGITEM-VALIDATE-VIEWDESC-DEPTHSTENCILATTACHMENT-PIXELFORMAT+
   +SG-LOGITEM-VALIDATE-VIEWDESC-DEPTHSTENCILATTACHMENT-USAGE+
   +SG-LOGITEM-VALIDATE-VIEWDESC-IMAGE-2D-SLICE+
   +SG-LOGITEM-VALIDATE-VIEWDESC-IMAGE-3D-SLICE+
   +SG-LOGITEM-VALIDATE-VIEWDESC-IMAGE-ARRAY-SLICE+
   +SG-LOGITEM-VALIDATE-VIEWDESC-IMAGE-CUBEMAP-SLICE+
   +SG-LOGITEM-VALIDATE-VIEWDESC-IMAGE-MIPLEVEL+
   +SG-LOGITEM-VALIDATE-VIEWDESC-RESOLVEATTACHMENT-SAMPLECOUNT+
   +SG-LOGITEM-VALIDATE-VIEWDESC-RESOLVEATTACHMENT-USAGE+
   +SG-LOGITEM-VALIDATE-VIEWDESC-RESOURCE-ALIVE+
   +SG-LOGITEM-VALIDATE-VIEWDESC-RESOURCE-FAILED+
   +SG-LOGITEM-VALIDATE-VIEWDESC-STORAGEBUFFER-OFFSET-MULTIPLE-256+
   +SG-LOGITEM-VALIDATE-VIEWDESC-STORAGEBUFFER-OFFSET-VS-BUFFER-SIZE+
   +SG-LOGITEM-VALIDATE-VIEWDESC-STORAGEBUFFER-USAGE+
   +SG-LOGITEM-VALIDATE-VIEWDESC-STORAGEIMAGE-PIXELFORMAT+
   +SG-LOGITEM-VALIDATE-VIEWDESC-STORAGEIMAGE-USAGE+
   +SG-LOGITEM-VALIDATE-VIEWDESC-TEXTURE-2D-SLICES+
   +SG-LOGITEM-VALIDATE-VIEWDESC-TEXTURE-3D-SLICES+
   +SG-LOGITEM-VALIDATE-VIEWDESC-TEXTURE-ARRAY-SLICES+
   +SG-LOGITEM-VALIDATE-VIEWDESC-TEXTURE-CUBEMAP-SLICES+
   +SG-LOGITEM-VALIDATE-VIEWDESC-TEXTURE-EXPECT-NO-MSAA+
   +SG-LOGITEM-VALIDATE-VIEWDESC-TEXTURE-MIPLEVELS+
   +SG-LOGITEM-VALIDATE-VIEWDESC-UNIQUE-VIEWTYPE+
   +SG-LOGITEM-VALIDATION-FAILED+
   +SG-LOGITEM-VIEW-POOL-EXHAUSTED+
   +SG-LOGITEM-VULKAN-ALLOC-BUFFER-DEVICE-MEMORY-FAILED+
   +SG-LOGITEM-VULKAN-ALLOC-DEVICE-MEMORY-NO-SUITABLE-MEMORY-TYPE+
   +SG-LOGITEM-VULKAN-ALLOC-IMAGE-DEVICE-MEMORY-FAILED+
   +SG-LOGITEM-VULKAN-ALLOCATE-MEMORY-FAILED+
   +SG-LOGITEM-VULKAN-ALLOCATE-SHARED-BUFFER-MEMORY-FAILED+
   +SG-LOGITEM-VULKAN-BIND-BUFFER-MEMORY-FAILED+
   +SG-LOGITEM-VULKAN-BIND-IMAGE-MEMORY-FAILED+
   +SG-LOGITEM-VULKAN-BIND-SHARED-BUFFER-MEMORY-FAILED+
   +SG-LOGITEM-VULKAN-CREATE-BUFFER-FAILED+
   +SG-LOGITEM-VULKAN-CREATE-COMPUTE-PIPELINE-FAILED+
   +SG-LOGITEM-VULKAN-CREATE-DESCRIPTOR-SET-LAYOUT-FAILED+
   +SG-LOGITEM-VULKAN-CREATE-GRAPHICS-PIPELINE-FAILED+
   +SG-LOGITEM-VULKAN-CREATE-IMAGE-FAILED+
   +SG-LOGITEM-VULKAN-CREATE-IMAGE-VIEW-FAILED+
   +SG-LOGITEM-VULKAN-CREATE-PIPELINE-LAYOUT-FAILED+
   +SG-LOGITEM-VULKAN-CREATE-SAMPLER-FAILED+
   +SG-LOGITEM-VULKAN-CREATE-SHADER-MODULE-FAILED+
   +SG-LOGITEM-VULKAN-CREATE-SHARED-BUFFER-FAILED+
   +SG-LOGITEM-VULKAN-DELETE-QUEUE-EXHAUSTED+
   +SG-LOGITEM-VULKAN-DESCRIPTOR-BUFFER-OVERFLOW+
   +SG-LOGITEM-VULKAN-MAP-SHARED-BUFFER-MEMORY-FAILED+
   +SG-LOGITEM-VULKAN-REQUIRED-EXTENSION-FUNCTION-MISSING+
   +SG-LOGITEM-VULKAN-SAMPLER-MAX-DESCRIPTOR-SIZE+
   +SG-LOGITEM-VULKAN-SAMPLER-SPIRV-SET1-BINDING-OUT-OF-RANGE+
   +SG-LOGITEM-VULKAN-STAGING-ALLOCATE-MEMORY-FAILED+
   +SG-LOGITEM-VULKAN-STAGING-BIND-BUFFER-MEMORY-FAILED+
   +SG-LOGITEM-VULKAN-STAGING-CREATE-BUFFER-FAILED+
   +SG-LOGITEM-VULKAN-STAGING-STREAM-BUFFER-OVERFLOW+
   +SG-LOGITEM-VULKAN-STORAGEBUFFER-SPIRV-SET1-BINDING-OUT-OF-RANGE+
   +SG-LOGITEM-VULKAN-STORAGEIMAGE-SPIRV-SET1-BINDING-OUT-OF-RANGE+
   +SG-LOGITEM-VULKAN-TEXTURE-SPIRV-SET1-BINDING-OUT-OF-RANGE+
   +SG-LOGITEM-VULKAN-UNIFORM-BUFFER-OVERFLOW+
   +SG-LOGITEM-VULKAN-UNIFORMBLOCK-SPIRV-SET0-BINDING-OUT-OF-RANGE+
   +SG-LOGITEM-VULKAN-VIEW-MAX-DESCRIPTOR-SIZE+
   +SG-LOGITEM-VULKAN-WAIT-FOR-FENCE-FAILED+
   +SG-LOGITEM-WGPU-BINDGROUPS-POOL-EXHAUSTED+
   +SG-LOGITEM-WGPU-BINDGROUPSCACHE-SIZE-GREATER-ONE+
   +SG-LOGITEM-WGPU-BINDGROUPSCACHE-SIZE-POW2+
   +SG-LOGITEM-WGPU-CREATE-BUFFER-FAILED+
   +SG-LOGITEM-WGPU-CREATE-COMPUTE-PIPELINE-FAILED+
   +SG-LOGITEM-WGPU-CREATE-PIPELINE-LAYOUT-FAILED+
   +SG-LOGITEM-WGPU-CREATE-RENDER-PIPELINE-FAILED+
   +SG-LOGITEM-WGPU-CREATE-SAMPLER-FAILED+
   +SG-LOGITEM-WGPU-CREATE-SHADER-MODULE-FAILED+
   +SG-LOGITEM-WGPU-CREATE-TEXTURE-FAILED+
   +SG-LOGITEM-WGPU-CREATE-TEXTURE-VIEW-FAILED+
   +SG-LOGITEM-WGPU-CREATEBINDGROUP-FAILED+
   +SG-LOGITEM-WGPU-SAMPLER-WGSL-GROUP1-BINDING-OUT-OF-RANGE+
   +SG-LOGITEM-WGPU-SHADER-CREATE-BINDGROUP-LAYOUT-FAILED+
   +SG-LOGITEM-WGPU-STORAGEBUFFER-WGSL-GROUP1-BINDING-OUT-OF-RANGE+
   +SG-LOGITEM-WGPU-STORAGEIMAGE-WGSL-GROUP1-BINDING-OUT-OF-RANGE+
   +SG-LOGITEM-WGPU-TEXTURE-WGSL-GROUP1-BINDING-OUT-OF-RANGE+
   +SG-LOGITEM-WGPU-UNIFORMBLOCK-WGSL-GROUP0-BINDING-OUT-OF-RANGE+
   +SG-PIXELFORMAT-ASTC-4x4-RGBA+
   +SG-PIXELFORMAT-ASTC-4x4-SRGBA+
   +SG-PIXELFORMAT-BC1-RGBA+
   +SG-PIXELFORMAT-BC2-RGBA+
   +SG-PIXELFORMAT-BC3-RGBA+
   +SG-PIXELFORMAT-BC3-SRGBA+
   +SG-PIXELFORMAT-BC4-R+
   +SG-PIXELFORMAT-BC4-RSN+
   +SG-PIXELFORMAT-BC5-RG+
   +SG-PIXELFORMAT-BC5-RGSN+
   +SG-PIXELFORMAT-BC6H-RGBF+
   +SG-PIXELFORMAT-BC6H-RGBUF+
   +SG-PIXELFORMAT-BC7-RGBA+
   +SG-PIXELFORMAT-BC7-SRGBA+
   +SG-PIXELFORMAT-BGRA8+
   +SG-PIXELFORMAT-DEPTH+
   +SG-PIXELFORMAT-DEPTH-STENCIL+
   +SG-PIXELFORMAT-EAC-R11+
   +SG-PIXELFORMAT-EAC-R11SN+
   +SG-PIXELFORMAT-EAC-RG11+
   +SG-PIXELFORMAT-EAC-RG11SN+
   +SG-PIXELFORMAT-ETC2-RGB8+
   +SG-PIXELFORMAT-ETC2-RGB8A1+
   +SG-PIXELFORMAT-ETC2-RGBA8+
   +SG-PIXELFORMAT-ETC2-SRGB8+
   +SG-PIXELFORMAT-ETC2-SRGB8A8+
   +SG-PIXELFORMAT-NONE+
   +SG-PIXELFORMAT-R16+
   +SG-PIXELFORMAT-R16F+
   +SG-PIXELFORMAT-R16SI+
   +SG-PIXELFORMAT-R16SN+
   +SG-PIXELFORMAT-R16UI+
   +SG-PIXELFORMAT-R32F+
   +SG-PIXELFORMAT-R32SI+
   +SG-PIXELFORMAT-R32UI+
   +SG-PIXELFORMAT-R8+
   +SG-PIXELFORMAT-R8SI+
   +SG-PIXELFORMAT-R8SN+
   +SG-PIXELFORMAT-R8UI+
   +SG-PIXELFORMAT-RG11B10F+
   +SG-PIXELFORMAT-RG16+
   +SG-PIXELFORMAT-RG16F+
   +SG-PIXELFORMAT-RG16SI+
   +SG-PIXELFORMAT-RG16SN+
   +SG-PIXELFORMAT-RG16UI+
   +SG-PIXELFORMAT-RG32F+
   +SG-PIXELFORMAT-RG32SI+
   +SG-PIXELFORMAT-RG32UI+
   +SG-PIXELFORMAT-RG8+
   +SG-PIXELFORMAT-RG8SI+
   +SG-PIXELFORMAT-RG8SN+
   +SG-PIXELFORMAT-RG8UI+
   +SG-PIXELFORMAT-RGB10A2+
   +SG-PIXELFORMAT-RGB9E5+
   +SG-PIXELFORMAT-RGBA16+
   +SG-PIXELFORMAT-RGBA16F+
   +SG-PIXELFORMAT-RGBA16SI+
   +SG-PIXELFORMAT-RGBA16SN+
   +SG-PIXELFORMAT-RGBA16UI+
   +SG-PIXELFORMAT-RGBA32F+
   +SG-PIXELFORMAT-RGBA32SI+
   +SG-PIXELFORMAT-RGBA32UI+
   +SG-PIXELFORMAT-RGBA8+
   +SG-PIXELFORMAT-RGBA8SI+
   +SG-PIXELFORMAT-RGBA8SN+
   +SG-PIXELFORMAT-RGBA8UI+
   +SG-PIXELFORMAT-SRGB8A8+
   +SG-PRIMITIVETYPE-LINE-STRIP+
   +SG-PRIMITIVETYPE-LINES+
   +SG-PRIMITIVETYPE-POINTS+
   +SG-PRIMITIVETYPE-TRIANGLE-STRIP+
   +SG-PRIMITIVETYPE-TRIANGLES+
   +SG-RESOURCESTATE-ALLOC+
   +SG-RESOURCESTATE-FAILED+
   +SG-RESOURCESTATE-INITIAL+
   +SG-RESOURCESTATE-INVALID+
   +SG-RESOURCESTATE-VALID+
   +SG-SAMPLERTYPE-COMPARISON+
   +SG-SAMPLERTYPE-FILTERING+
   +SG-SAMPLERTYPE-NONFILTERING+
   +SG-SHADERATTRBASETYPE-FLOAT+
   +SG-SHADERATTRBASETYPE-SINT+
   +SG-SHADERATTRBASETYPE-UINT+
   +SG-SHADERATTRBASETYPE-UNDEFINED+
   +SG-SHADERSTAGE-COMPUTE+
   +SG-SHADERSTAGE-FRAGMENT+
   +SG-SHADERSTAGE-NONE+
   +SG-SHADERSTAGE-VERTEX+
   +SG-STENCILOP-DECR-CLAMP+
   +SG-STENCILOP-DECR-WRAP+
   +SG-STENCILOP-INCR-CLAMP+
   +SG-STENCILOP-INCR-WRAP+
   +SG-STENCILOP-INVERT+
   +SG-STENCILOP-KEEP+
   +SG-STENCILOP-REPLACE+
   +SG-STENCILOP-ZERO+
   +SG-STOREACTION-DONTCARE+
   +SG-STOREACTION-STORE+
   +SG-UNIFORMLAYOUT-NATIVE+
   +SG-UNIFORMLAYOUT-STD140+
   +SG-UNIFORMTYPE-FLOAT+
   +SG-UNIFORMTYPE-FLOAT2+
   +SG-UNIFORMTYPE-FLOAT3+
   +SG-UNIFORMTYPE-FLOAT4+
   +SG-UNIFORMTYPE-INT+
   +SG-UNIFORMTYPE-INT2+
   +SG-UNIFORMTYPE-INT3+
   +SG-UNIFORMTYPE-INT4+
   +SG-UNIFORMTYPE-INVALID+
   +SG-UNIFORMTYPE-MAT4+
   +SG-VERTEXFORMAT-BYTE4+
   +SG-VERTEXFORMAT-BYTE4N+
   +SG-VERTEXFORMAT-FLOAT+
   +SG-VERTEXFORMAT-FLOAT2+
   +SG-VERTEXFORMAT-FLOAT3+
   +SG-VERTEXFORMAT-FLOAT4+
   +SG-VERTEXFORMAT-HALF2+
   +SG-VERTEXFORMAT-HALF4+
   +SG-VERTEXFORMAT-INT+
   +SG-VERTEXFORMAT-INT2+
   +SG-VERTEXFORMAT-INT3+
   +SG-VERTEXFORMAT-INT4+
   +SG-VERTEXFORMAT-INVALID+
   +SG-VERTEXFORMAT-SHORT2+
   +SG-VERTEXFORMAT-SHORT2N+
   +SG-VERTEXFORMAT-SHORT4+
   +SG-VERTEXFORMAT-SHORT4N+
   +SG-VERTEXFORMAT-UBYTE4+
   +SG-VERTEXFORMAT-UBYTE4N+
   +SG-VERTEXFORMAT-UINT+
   +SG-VERTEXFORMAT-UINT10-N2+
   +SG-VERTEXFORMAT-UINT2+
   +SG-VERTEXFORMAT-UINT3+
   +SG-VERTEXFORMAT-UINT4+
   +SG-VERTEXFORMAT-USHORT2+
   +SG-VERTEXFORMAT-USHORT2N+
   +SG-VERTEXFORMAT-USHORT4+
   +SG-VERTEXFORMAT-USHORT4N+
   +SG-VERTEXSTEP-PER-INSTANCE+
   +SG-VERTEXSTEP-PER-VERTEX+
   +SG-VIEWTYPE-COLORATTACHMENT+
   +SG-VIEWTYPE-DEPTHSTENCILATTACHMENT+
   +SG-VIEWTYPE-INVALID+
   +SG-VIEWTYPE-RESOLVEATTACHMENT+
   +SG-VIEWTYPE-STORAGEBUFFER+
   +SG-VIEWTYPE-STORAGEIMAGE+
   +SG-VIEWTYPE-TEXTURE+
   +SG-WRAP-CLAMP-TO-BORDER+
   +SG-WRAP-CLAMP-TO-EDGE+
   +SG-WRAP-MIRRORED-REPEAT+
   +SG-WRAP-REPEAT+
   sg-add-commit-listener
   sg-alloc-buffer
   sg-alloc-image
   sg-alloc-pipeline
   sg-alloc-sampler
   sg-alloc-shader
   sg-alloc-view
   sg-allocator
   sg-append-buffer
   sg-apply-bindings
   sg-apply-pipeline
   sg-apply-scissor-rect
   sg-apply-scissor-rectf
   sg-apply-uniforms
   sg-apply-viewport
   sg-apply-viewportf
   sg-attachments
   sg-backend
   sg-begin-pass
   sg-bindings
   sg-blend-factor
   sg-blend-op
   sg-blend-state
   sg-border-color
   sg-buffer
   sg-buffer-desc
   sg-buffer-info
   sg-buffer-usage
   sg-buffer-view-desc
   sg-color
   sg-color-attachment-action
   sg-color-mask
   sg-color-target-state
   sg-commit
   sg-commit-listener
   sg-compare-func
   sg-cull-mode
   sg-d3d11-buffer-info
   sg-d3d11-desc
   sg-d3d11-device
   sg-d3d11-device-context
   sg-d3d11-environment
   sg-d3d11-image-info
   sg-d3d11-pipeline-info
   sg-d3d11-query-buffer-info
   sg-d3d11-query-image-info
   sg-d3d11-query-pipeline-info
   sg-d3d11-query-sampler-info
   sg-d3d11-query-shader-info
   sg-d3d11-query-view-info
   sg-d3d11-sampler-info
   sg-d3d11-shader-info
   sg-d3d11-swapchain
   sg-d3d11-view-info
   sg-dealloc-buffer
   sg-dealloc-image
   sg-dealloc-pipeline
   sg-dealloc-sampler
   sg-dealloc-shader
   sg-dealloc-view
   sg-depth-attachment-action
   sg-depth-state
   sg-desc
   sg-destroy-buffer
   sg-destroy-image
   sg-destroy-pipeline
   sg-destroy-sampler
   sg-destroy-shader
   sg-destroy-view
   sg-disable-stats
   sg-dispatch
   sg-draw
   sg-draw-ex
   sg-enable-stats
   sg-end-pass
   sg-environment
   sg-environment-defaults
   sg-face-winding
   sg-fail-buffer
   sg-fail-image
   sg-fail-pipeline
   sg-fail-sampler
   sg-fail-shader
   sg-fail-view
   sg-features
   sg-filter
   sg-frame-resource-stats
   sg-frame-stats
   sg-frame-stats-d3d11
   sg-frame-stats-d3d11-bindings
   sg-frame-stats-d3d11-draw
   sg-frame-stats-d3d11-pass
   sg-frame-stats-d3d11-pipeline
   sg-frame-stats-d3d11-uniforms
   sg-frame-stats-gl
   sg-frame-stats-metal
   sg-frame-stats-metal-bindings
   sg-frame-stats-metal-idpool
   sg-frame-stats-metal-pipeline
   sg-frame-stats-metal-uniforms
   sg-frame-stats-vk
   sg-frame-stats-wgpu
   sg-frame-stats-wgpu-bindings
   sg-frame-stats-wgpu-uniforms
   sg-gl-buffer-info
   sg-gl-image-info
   sg-gl-query-buffer-info
   sg-gl-query-image-info
   sg-gl-query-sampler-info
   sg-gl-query-shader-info
   sg-gl-query-view-info
   sg-gl-sampler-info
   sg-gl-shader-info
   sg-gl-swapchain
   sg-gl-view-info
   sg-glsl-shader-uniform
   sg-image
   sg-image-data
   sg-image-desc
   sg-image-info
   sg-image-sample-type
   sg-image-type
   sg-image-usage
   sg-image-view-desc
   sg-index-type
   sg-init-buffer
   sg-init-image
   sg-init-pipeline
   sg-init-sampler
   sg-init-shader
   sg-init-view
   sg-install-trace-hooks
   sg-isvalid
   sg-limits
   sg-load-action
   sg-log-item
   sg-logger
   sg-make-buffer
   sg-make-image
   sg-make-pipeline
   sg-make-sampler
   sg-make-shader
   sg-make-view
   sg-metal-desc
   sg-metal-environment
   sg-metal-swapchain
   sg-mtl-buffer-info
   sg-mtl-compute-command-encoder
   sg-mtl-device
   sg-mtl-image-info
   sg-mtl-pipeline-info
   sg-mtl-query-buffer-info
   sg-mtl-query-image-info
   sg-mtl-query-pipeline-info
   sg-mtl-query-sampler-info
   sg-mtl-query-shader-info
   sg-mtl-render-command-encoder
   sg-mtl-sampler-info
   sg-mtl-shader-info
   sg-mtl-shader-threads-per-threadgroup
   sg-pass
   sg-pass-action
   sg-pipeline
   sg-pipeline-desc
   sg-pipeline-info
   sg-pixel-format
   sg-pixelformat-info
   sg-pop-debug-group
   sg-primitive-type
   sg-push-debug-group
   sg-query-backend
   sg-query-buffer-defaults
   sg-query-buffer-desc
   sg-query-buffer-info
   sg-query-buffer-overflow
   sg-query-buffer-size
   sg-query-buffer-state
   sg-query-buffer-usage
   sg-query-buffer-will-overflow
   sg-query-desc
   sg-query-features
   sg-query-image-defaults
   sg-query-image-desc
   sg-query-image-height
   sg-query-image-info
   sg-query-image-num-mipmaps
   sg-query-image-num-slices
   sg-query-image-pixelformat
   sg-query-image-sample-count
   sg-query-image-state
   sg-query-image-type
   sg-query-image-usage
   sg-query-image-width
   sg-query-limits
   sg-query-pipeline-defaults
   sg-query-pipeline-desc
   sg-query-pipeline-info
   sg-query-pipeline-state
   sg-query-pixelformat
   sg-query-row-pitch
   sg-query-sampler-defaults
   sg-query-sampler-desc
   sg-query-sampler-info
   sg-query-sampler-state
   sg-query-shader-defaults
   sg-query-shader-desc
   sg-query-shader-info
   sg-query-shader-state
   sg-query-stats
   sg-query-surface-pitch
   sg-query-view-buffer
   sg-query-view-defaults
   sg-query-view-desc
   sg-query-view-image
   sg-query-view-info
   sg-query-view-state
   sg-query-view-type
   sg-range
   sg-remove-commit-listener
   sg-reset-state-cache
   sg-resource-state
   sg-sampler
   sg-sampler-desc
   sg-sampler-info
   sg-sampler-type
   sg-setup
   sg-shader
   sg-shader-attr-base-type
   sg-shader-desc
   sg-shader-function
   sg-shader-info
   sg-shader-sampler
   sg-shader-stage
   sg-shader-storage-buffer-view
   sg-shader-storage-image-view
   sg-shader-texture-sampler-pair
   sg-shader-texture-view
   sg-shader-uniform-block
   sg-shader-vertex-attr
   sg-shader-view
   sg-shutdown
   sg-slot-info
   sg-stats
   sg-stats-enabled
   sg-stencil-attachment-action
   sg-stencil-face-state
   sg-stencil-op
   sg-stencil-state
   sg-store-action
   sg-swapchain
   sg-texture-view-desc
   sg-texture-view-range
   sg-total-resource-stats
   sg-total-stats
   sg-trace-hooks
   sg-uniform-layout
   sg-uniform-type
   sg-uninit-buffer
   sg-uninit-image
   sg-uninit-pipeline
   sg-uninit-sampler
   sg-uninit-shader
   sg-uninit-view
   sg-update-buffer
   sg-update-image
   sg-vertex-attr-state
   sg-vertex-buffer-layout-state
   sg-vertex-format
   sg-vertex-layout-state
   sg-vertex-step
   sg-view
   sg-view-desc
   sg-view-info
   sg-view-type
   sg-vulkan-desc
   sg-vulkan-environment
   sg-vulkan-swapchain
   sg-wgpu-buffer-info
   sg-wgpu-command-encoder
   sg-wgpu-compute-pass-encoder
   sg-wgpu-desc
   sg-wgpu-device
   sg-wgpu-environment
   sg-wgpu-image-info
   sg-wgpu-pipeline-info
   sg-wgpu-query-buffer-info
   sg-wgpu-query-image-info
   sg-wgpu-query-pipeline-info
   sg-wgpu-query-sampler-info
   sg-wgpu-query-shader-info
   sg-wgpu-query-view-info
   sg-wgpu-queue
   sg-wgpu-render-pass-encoder
   sg-wgpu-sampler-info
   sg-wgpu-shader-info
   sg-wgpu-swapchain
   sg-wgpu-view-info
   sg-wrap
   ))

(in-package :sokol-gfx)

;;;; Original header documentation:
;;;; sokol_gfx.h -- simple 3D API wrapper
;;;; 
;;;;     Project URL: https://github.com/floooh/sokol
;;;; 
;;;;     Example code: https://github.com/floooh/sokol-samples
;;;; 
;;;;     Do this:
;;;;         #define SOKOL_IMPL or
;;;;         #define SOKOL_GFX_IMPL
;;;;     before you include this file in *one* C or C++ file to create the
;;;;     implementation.
;;;; 
;;;;     In the same place define one of the following to select the rendering
;;;;     backend:
;;;;         #define SOKOL_GLCORE
;;;;         #define SOKOL_GLES3
;;;;         #define SOKOL_D3D11
;;;;         #define SOKOL_METAL
;;;;         #define SOKOL_WGPU
;;;;         #define SOKOL_VULKAN
;;;;         #define SOKOL_DUMMY_BACKEND
;;;; 
;;;;     I.e. for the desktop GL it should look like this:
;;;; 
;;;;     #include ...
;;;;     #include ...
;;;;     #define SOKOL_IMPL
;;;;     #define SOKOL_GLCORE
;;;;     #include "sokol_gfx.h"
;;;; 
;;;;     The dummy backend replaces the platform-specific backend code with empty
;;;;     stub functions. This is useful for writing tests that need to run on the
;;;;     command line.
;;;; 
;;;;     Optionally provide the following defines with your own implementations:
;;;; 
;;;;     SOKOL_ASSERT(c)             - your own assert macro (default: assert(c))
;;;;     SOKOL_UNREACHABLE()         - a guard macro for unreachable code (default: assert(false))
;;;;     SOKOL_GFX_API_DECL          - public function declaration prefix (default: extern)
;;;;     SOKOL_API_DECL              - same as SOKOL_GFX_API_DECL
;;;;     SOKOL_API_IMPL              - public function implementation prefix (default: -)
;;;;     SOKOL_TRACE_HOOKS           - enable trace hook callbacks (search below for TRACE HOOKS)
;;;;     SOKOL_EXTERNAL_GL_LOADER    - indicates that you're using your own GL loader, in this case
;;;;                                   sokol_gfx.h will not include any platform GL headers and disable
;;;;                                   the integrated Win32 GL loader
;;;; 
;;;;     If sokol_gfx.h is compiled as a DLL, define the following before
;;;;     including the declaration or implementation:
;;;; 
;;;;     SOKOL_DLL
;;;; 
;;;;     On Windows, SOKOL_DLL will define SOKOL_GFX_API_DECL as __declspec(dllexport)
;;;;     or __declspec(dllimport) as needed.
;;;; 
;;;;     Optionally define the following to force debug checks and validations
;;;;     even in release mode:
;;;; 
;;;;     SOKOL_DEBUG - by default this is defined if NDEBUG is not defined
;;;; 
;;;;     Link with the following system libraries (note that sokol_app.h has
;;;;     additional linker requirements):
;;;; 
;;;;     - on macOS/iOS with Metal: Metal
;;;;     - on macOS with GL: OpenGL
;;;;     - on iOS with GL: OpenGLES
;;;;     - on Linux with EGL: GL or GLESv2
;;;;     - on Linux with GLX: GL
;;;;     - on Android: GLESv3, log, android
;;;;     - on Windows with the MSVC or Clang toolchains: no action needed, libs are defined in-source via pragma-comment-lib
;;;;     - on Windows with MINGW/MSYS2 gcc: compile with '-mwin32' so that _WIN32 is defined
;;;;         - with the D3D11 backend: -ld3d11
;;;; 
;;;;     On macOS and iOS, the implementation must be compiled as Objective-C.
;;;; 
;;;;     On Emscripten:
;;;;         - for WebGL2: add the linker option `-s USE_WEBGL2=1`
;;;;         - for WebGPU: compile and link with `--use-port=emdawnwebgpu`
;;;;           (for more exotic situations, read: https://dawn.googlesource.com/dawn/+/refs/heads/main/src/emdawnwebgpu/pkg/README.md)
;;;; 
;;;;     sokol_gfx DOES NOT:
;;;;     ===================
;;;;     - create a window, swapchain or the 3D-API context/device, you must do this
;;;;       before sokol_gfx is initialized, and pass any required information
;;;;       (like 3D device pointers) to the sokol_gfx initialization call
;;;; 
;;;;     - present the rendered frame, how this is done exactly usually depends
;;;;       on how the window and 3D-API context/device was created
;;;; 
;;;;     - provide a unified shader language, instead 3D-API-specific shader
;;;;       source-code or shader-bytecode must be provided (for the "official"
;;;;       offline shader cross-compiler / code-generator, see here:
;;;;       https://github.com/floooh/sokol-tools/blob/master/docs/sokol-shdc.md)
;;;; 
;;;; 
;;;;     STEP BY STEP
;;;;     ============
;;;;     --- to initialize sokol_gfx, after creating a window and a 3D-API
;;;;         context/device, call:
;;;; 
;;;;             sg_setup(const sg_desc*)
;;;; 
;;;;         Depending on the selected 3D backend, sokol-gfx requires some
;;;;         information about its runtime environment, like a GPU device pointer,
;;;;         default swapchain pixel formats and so on. If you are using sokol_app.h
;;;;         for the window system glue, you can use a helper function provided in
;;;;         the sokol_glue.h header:
;;;; 
;;;;             #include "sokol_gfx.h"
;;;;             #include "sokol_app.h"
;;;;             #include "sokol_glue.h"
;;;;             //...
;;;;             sg_setup(&(sg_desc){
;;;;                 .environment = sglue_environment(),
;;;;             });
;;;; 
;;;;         To get any logging output for errors and from the validation layer, you
;;;;         need to provide a logging callback. Easiest way is through sokol_log.h:
;;;; 
;;;;             #include "sokol_log.h"
;;;;             //...
;;;;             sg_setup(&(sg_desc){
;;;;                 //...
;;;;                 .logger.func = slog_func,
;;;;             });
;;;; 
;;;;     --- create resource objects (buffers, images, views, samplers, shaders
;;;;         and pipeline objects)
;;;; 
;;;;             sg_buffer sg_make_buffer(const sg_buffer_desc*)
;;;;             sg_image sg_make_image(const sg_image_desc*)
;;;;             sg_view sg_make_view(const sg_view_desc*)
;;;;             sg_sampler sg_make_sampler(const sg_sampler_desc*)
;;;;             sg_shader sg_make_shader(const sg_shader_desc*)
;;;;             sg_pipeline sg_make_pipeline(const sg_pipeline_desc*)
;;;; 
;;;;     --- start a render- or compute-pass:
;;;; 
;;;;             sg_begin_pass(const sg_pass* pass);
;;;; 
;;;;         Typically, render passes render into an externally provided swapchain which
;;;;         presents the rendering result on the display. Such a 'swapchain pass'
;;;;         is started like this:
;;;; 
;;;;             sg_begin_pass(&(sg_pass){ .action = { ... }, .swapchain = sglue_swapchain() })
;;;; 
;;;;         ...where .action is an sg_pass_action struct containing actions to be performed
;;;;         at the start and end of a render pass (such as clearing the render surfaces to
;;;;         a specific color), and .swapchain is an sg_swapchain struct with all the required
;;;;         information to render into the swapchain's surfaces.
;;;; 
;;;;         To start an 'offscreen render pass' into sokol-gfx image objects, populate
;;;;         the sg_pass.attachments nested struct with attachment view objects
;;;;         (1..4 color-attachment-views for to render into, a depth-stencil-attachment-view
;;;;         to provide the depth-stencil-buffer, and optionally 1..4 resolve-attachment-views
;;;;         for an MSAA-resolve operation:
;;;; 
;;;;             sg_begin_pass(&(sg_pass){
;;;;                 .action = { ... },
;;;;                 .attachments = {
;;;;                     .colors[0] = color_attachment_view,
;;;;                     .resolves[0] = optional_resolve_attachment_view,
;;;;                     .depth_stencil = depth_stencil_attachment_view,
;;;;                 },
;;;;             });
;;;; 
;;;;         To start a compute-pass, just set the .compute item to true:
;;;; 
;;;;             sg_begin_pass(&(sg_pass){ .compute = true });
;;;; 
;;;;     --- set the pipeline state for the next draw call with:
;;;; 
;;;;             sg_apply_pipeline(sg_pipeline pip)
;;;; 
;;;;     --- fill an sg_bindings struct with the resource bindings for the next
;;;;         draw- or dispatch-call (0..N vertex buffers, 0 or 1 index buffer, 0..N views,
;;;;         0..N samplers), and call
;;;; 
;;;;             sg_apply_bindings(const sg_bindings* bindings)
;;;; 
;;;;         ...to update the resource bindings. Note that in a compute pass, no vertex-
;;;;         or index-buffer bindings can be used, and in render passes, no storage-image bindings
;;;;         are allowed. Those restrictions will be checked by the sokol-gfx validation layer.
;;;; 
;;;;     --- optionally update shader uniform data with:
;;;; 
;;;;             sg_apply_uniforms(int ub_slot, const sg_range* data)
;;;; 
;;;;         Read the section 'UNIFORM DATA LAYOUT' to learn about the expected memory layout
;;;;         of the uniform data passed into sg_apply_uniforms().
;;;; 
;;;;     --- kick off a draw call with:
;;;; 
;;;;             sg_draw(int base_element, int num_elements, int num_instances)
;;;; 
;;;;         The sg_draw() function unifies all the different ways to render primitives
;;;;         in a single call (indexed vs non-indexed rendering, and instanced vs non-instanced
;;;;         rendering). In case of indexed rendering, base_element and num_element specify
;;;;         indices in the currently bound index buffer. In case of non-indexed rendering
;;;;         base_element and num_elements specify vertices in the currently bound
;;;;         vertex-buffer(s). To perform instanced rendering, the rendering pipeline
;;;;         must be setup for instancing (see sg_pipeline_desc below), a separate vertex buffer
;;;;         containing per-instance data must be bound, and the num_instances parameter
;;;;         must be > 1.
;;;; 
;;;;         Alternatively, call:
;;;; 
;;;;             sg_draw_ex(...)
;;;; 
;;;;         to provide a base-vertex and/or base-instance which allows to render
;;;;         from different sections of a vertex buffer without rebinding the
;;;;         vertex buffer with a different offset. Note that the `sg_draw_ex()`
;;;;         only has limited portability on OpenGL, check the sg_limits struct
;;;;         members .draw_base_vertex and .draw_base_instance for runtime support,
;;;;         those are generally true on non-GL-backends, and on GL the feature
;;;;         flags are set according to the GL version:
;;;; 
;;;;             - on GL base_instance != 0 is only supported since GL 4.2
;;;;             - on GLES3.x, base_instance != 0 is not supported
;;;;             - on GLES3.x, base_vertex is only supported since GLES3.2
;;;;               (e.g. not supported on WebGL2)
;;;; 
;;;;     --- ...or kick of a dispatch call to invoke a compute shader workload:
;;;; 
;;;;             sg_dispatch(int num_groups_x, int num_groups_y, int num_groups_z)
;;;; 
;;;;         The dispatch args define the number of 'compute workgroups' processed
;;;;         by the currently applied compute shader.
;;;; 
;;;;     --- finish the current pass with:
;;;; 
;;;;             sg_end_pass()
;;;; 
;;;;     --- when done with the current frame, call
;;;; 
;;;;             sg_commit()
;;;; 
;;;;     --- at the end of your program, shutdown sokol_gfx with:
;;;; 
;;;;             sg_shutdown()
;;;; 
;;;;     --- if you need to destroy resources before sg_shutdown(), call:
;;;; 
;;;;             sg_destroy_buffer(sg_buffer buf)
;;;;             sg_destroy_image(sg_image img)
;;;;             sg_destroy_sampler(sg_sampler smp)
;;;;             sg_destroy_shader(sg_shader shd)
;;;;             sg_destroy_pipeline(sg_pipeline pip)
;;;;             sg_destroy_view(sg_view view)
;;;; 
;;;;     --- to set a new viewport rectangle, call:
;;;; 
;;;;             sg_apply_viewport(int x, int y, int width, int height, bool origin_top_left)
;;;; 
;;;;         ...or if you want to specify the viewport rectangle with float values:
;;;; 
;;;;             sg_apply_viewportf(float x, float y, float width, float height, bool origin_top_left)
;;;; 
;;;;     --- to set a new scissor rect, call:
;;;; 
;;;;             sg_apply_scissor_rect(int x, int y, int width, int height, bool origin_top_left)
;;;; 
;;;;         ...or with float values:
;;;; 
;;;;             sg_apply_scissor_rectf(float x, float y, float width, float height, bool origin_top_left)
;;;; 
;;;;         Both sg_apply_viewport() and sg_apply_scissor_rect() must be called
;;;;         inside a rendering pass (e.g. not in a compute pass, or outside a pass)
;;;; 
;;;;         Note that sg_begin_pass() will reset both the viewport and scissor
;;;;         rectangles to cover the entire framebuffer.
;;;; 
;;;;     --- to update (overwrite) the content of buffer and image resources, call:
;;;; 
;;;;             sg_update_buffer(sg_buffer buf, const sg_range* data)
;;;;             sg_update_image(sg_image img, const sg_image_data* data)
;;;; 
;;;;         Buffers and images to be updated must have been created with
;;;;         sg_buffer_desc.usage.dynamic_update or .stream_update.
;;;; 
;;;;         Only one update per frame is allowed for buffer and image resources when
;;;;         using the sg_update_*() functions. The rationale is to have a simple
;;;;         protection from the CPU scribbling over data the GPU is currently
;;;;         using, or the CPU having to wait for the GPU
;;;; 
;;;;         Buffer and image updates can be partial, as long as a rendering
;;;;         operation only references the valid (updated) data in the
;;;;         buffer or image.
;;;; 
;;;;     --- to append a chunk of data to a buffer resource, call:
;;;; 
;;;;             int sg_append_buffer(sg_buffer buf, const sg_range* data)
;;;; 
;;;;         The difference to sg_update_buffer() is that sg_append_buffer()
;;;;         can be called multiple times per frame to append new data to the
;;;;         buffer piece by piece, optionally interleaved with draw calls referencing
;;;;         the previously written data.
;;;; 
;;;;         sg_append_buffer() returns a byte offset to the start of the
;;;;         written data, this offset can be assigned to
;;;;         sg_bindings.vertex_buffer_offsets[n] or
;;;;         sg_bindings.index_buffer_offset
;;;; 
;;;;         Code example:
;;;; 
;;;;         for (...) {
;;;;             const void* data = ...;
;;;;             const int num_bytes = ...;
;;;;             int offset = sg_append_buffer(buf, &(sg_range) { .ptr=data, .size=num_bytes });
;;;;             bindings.vertex_buffer_offsets[0] = offset;
;;;;             sg_apply_pipeline(pip);
;;;;             sg_apply_bindings(&bindings);
;;;;             sg_apply_uniforms(...);
;;;;             sg_draw(...);
;;;;         }
;;;; 
;;;;         A buffer to be used with sg_append_buffer() must have been created
;;;;         with sg_buffer_desc.usage.dynamic_update or .stream_update.
;;;; 
;;;;         If the application appends more data to the buffer then fits into
;;;;         the buffer, the buffer will go into the "overflow" state for the
;;;;         rest of the frame.
;;;; 
;;;;         Any draw calls attempting to render an overflown buffer will be
;;;;         silently dropped (in debug mode this will also result in a
;;;;         validation error).
;;;; 
;;;;         You can also check manually if a buffer is in overflow-state by calling
;;;; 
;;;;             bool sg_query_buffer_overflow(sg_buffer buf)
;;;; 
;;;;         You can manually check to see if an overflow would occur before adding
;;;;         any data to a buffer by calling
;;;; 
;;;;             bool sg_query_buffer_will_overflow(sg_buffer buf, size_t size)
;;;; 
;;;;         NOTE: Due to restrictions in underlying 3D-APIs, appended chunks of
;;;;         data will be 4-byte aligned in the destination buffer. This means
;;;;         that there will be gaps in index buffers containing 16-bit indices
;;;;         when the number of indices in a call to sg_append_buffer() is
;;;;         odd. This isn't a problem when each call to sg_append_buffer()
;;;;         is associated with one draw call, but will be problematic when
;;;;         a single indexed draw call spans several appended chunks of indices.
;;;; 
;;;;     --- to check at runtime for optional features, limits and pixelformat support,
;;;;         call:
;;;; 
;;;;             sg_features sg_query_features()
;;;;             sg_limits sg_query_limits()
;;;;             sg_pixelformat_info sg_query_pixelformat(sg_pixel_format fmt)
;;;; 
;;;;     --- if you need to call into the underlying 3D-API directly, you must call:
;;;; 
;;;;             sg_reset_state_cache()
;;;; 
;;;;         ...before calling sokol_gfx functions again
;;;; 
;;;;     --- you can inspect the original sg_desc structure handed to sg_setup()
;;;;         by calling sg_query_desc(). This will return an sg_desc struct with
;;;;         the default values patched in instead of any zero-initialized values
;;;; 
;;;;     --- you can get a desc struct matching the creation attributes of a
;;;;         specific resource object via:
;;;; 
;;;;             sg_buffer_desc sg_query_buffer_desc(sg_buffer buf)
;;;;             sg_image_desc sg_query_image_desc(sg_image img)
;;;;             sg_sampler_desc sg_query_sampler_desc(sg_sampler smp)
;;;;             sg_shader_desc sq_query_shader_desc(sg_shader shd)
;;;;             sg_pipeline_desc sg_query_pipeline_desc(sg_pipeline pip)
;;;;             sg_view_desc sg_query_view_desc(sg_view view)
;;;; 
;;;;         ...but NOTE that the returned desc structs may be incomplete, only
;;;;         creation attributes that are kept around internally after resource
;;;;         creation will be filled in, and in some cases (like shaders) that's
;;;;         very little. Any missing attributes will be set to zero. The returned
;;;;         desc structs might still be useful as partial blueprint for creating
;;;;         similar resources if filled up with the missing attributes.
;;;; 
;;;;         Calling the query-desc functions on an invalid resource will return
;;;;         completely zeroed structs (it makes sense to check  the resource state
;;;;         with sg_query_*_state() first)
;;;; 
;;;;     --- you can query the default resource creation parameters through the functions
;;;; 
;;;;             sg_buffer_desc sg_query_buffer_defaults(const sg_buffer_desc* desc)
;;;;             sg_image_desc sg_query_image_defaults(const sg_image_desc* desc)
;;;;             sg_sampler_desc sg_query_sampler_defaults(const sg_sampler_desc* desc)
;;;;             sg_shader_desc sg_query_shader_defaults(const sg_shader_desc* desc)
;;;;             sg_pipeline_desc sg_query_pipeline_defaults(const sg_pipeline_desc* desc)
;;;;             sg_view_desc sg_query_view_defaults(const sg_view_desc* desc)
;;;; 
;;;;         These functions take a pointer to a desc structure which may contain
;;;;         zero-initialized items for default values. These zero-init values
;;;;         will be replaced with their concrete values in the returned desc
;;;;         struct.
;;;; 
;;;;     --- you can inspect various internal resource runtime values via:
;;;; 
;;;;             sg_buffer_info sg_query_buffer_info(sg_buffer buf)
;;;;             sg_image_info sg_query_image_info(sg_image img)
;;;;             sg_sampler_info sg_query_sampler_info(sg_sampler smp)
;;;;             sg_shader_info sg_query_shader_info(sg_shader shd)
;;;;             sg_pipeline_info sg_query_pipeline_info(sg_pipeline pip)
;;;;             sg_view_info sg_query_view_info(sg_view view)
;;;; 
;;;;         ...please note that the returned info-structs are tied quite closely
;;;;         to sokol_gfx.h internals, and may change more often than other
;;;;         public API functions and structs.
;;;; 
;;;;     -- you can query the type/flavour and parent resource of a view:
;;;; 
;;;;             sg_view_type sg_query_view_type(sg_view view)
;;;;             sg_image sg_query_view_image(sg_view view)
;;;;             sg_buffer sg_query_view_buffer(sg_view view)
;;;; 
;;;;     --- you can query stats and control stats collection via:
;;;; 
;;;;             sg_query_stats()
;;;;             sg_enable_stats()
;;;;             sg_disable_stats()
;;;;             sg_stats_enabled()
;;;; 
;;;;     --- you can ask at runtime what backend sokol_gfx.h has been compiled for:
;;;; 
;;;;             sg_backend sg_query_backend(void)
;;;; 
;;;;     --- call the following helper functions to compute the number of
;;;;         bytes in a texture row or surface for a specific pixel format.
;;;;         These functions might be helpful when preparing image data for consumption
;;;;         by sg_make_image() or sg_update_image():
;;;; 
;;;;             int sg_query_row_pitch(sg_pixel_format fmt, int width, int int row_align_bytes);
;;;;             int sg_query_surface_pitch(sg_pixel_format fmt, int width, int height, int row_align_bytes);
;;;; 
;;;;         Width and height are generally in number pixels, but note that 'row' has different meaning
;;;;         for uncompressed vs compressed pixel formats: for uncompressed formats, a row is identical
;;;;         with a single line if pixels, while in compressed formats, one row is a line of *compression blocks*.
;;;; 
;;;;         This is why calling sg_query_surface_pitch() for a compressed pixel format and height
;;;;         N, N+1, N+2, ... may return the same result.
;;;; 
;;;;         The row_align_bytes parameter is for added flexibility. For image data that goes into
;;;;         the sg_make_image() or sg_update_image() this should generally be 1, because these
;;;;         functions take tightly packed image data as input no matter what alignment restrictions
;;;;         exist in the backend 3D APIs.
;;;; 
;;;;     ON INITIALIZATION:
;;;;     ==================
;;;;     When calling sg_setup(), a pointer to an sg_desc struct must be provided
;;;;     which contains initialization options. These options provide two types
;;;;     of information to sokol-gfx:
;;;; 
;;;;         (1) upper bounds and limits needed to allocate various internal
;;;;             data structures:
;;;;                 - the max number of resources of each type that can
;;;;                   be alive at the same time, this is used for allocating
;;;;                   internal pools
;;;;                 - the max overall size of uniform data that can be
;;;;                   updated per frame, including a worst-case alignment
;;;;                   per uniform update (this worst-case alignment is 256 bytes)
;;;;                 - the max size of all dynamic resource updates (sg_update_buffer,
;;;;                   sg_append_buffer and sg_update_image) per frame
;;;;                 - the max number of compute-dispatch calls in a compute pass
;;;;             Not all of those limit values are used by all backends, but it is
;;;;             good practice to provide them none-the-less.
;;;; 
;;;;         (2) 3D backend "environment information" in a nested sg_environment struct:
;;;;             - pointers to backend-specific context- or device-objects (for instance
;;;;               the D3D11, WebGPU or Metal device objects)
;;;;             - defaults for external swapchain pixel formats and sample counts,
;;;;               these will be used as default values in image and pipeline objects,
;;;;               and the sg_swapchain struct passed into sg_begin_pass()
;;;;             Usually you provide a complete sg_environment struct through
;;;;             a helper function, as an example look at the sglue_environment()
;;;;             function in the sokol_glue.h header.
;;;; 
;;;;     See the documentation block of the sg_desc struct below for more information.
;;;; 
;;;; 
;;;;     ON RENDER PASSES
;;;;     ================
;;;;     Relevant samples:
;;;;         - https://floooh.github.io/sokol-html5/offscreen-sapp.html
;;;;         - https://floooh.github.io/sokol-html5/offscreen-msaa-sapp.html
;;;;         - https://floooh.github.io/sokol-html5/mrt-sapp.html
;;;;         - https://floooh.github.io/sokol-html5/mrt-pixelformats-sapp.html
;;;; 
;;;;     A render pass groups rendering commands into a set of render target images
;;;;     (called 'render pass attachments'). Render target images can be used in subsequent
;;;;     passes as textures (it is invalid to use the same image both as render target
;;;;     and as texture in the same pass).
;;;; 
;;;;     The following sokol-gfx functions must only be called inside a render-pass:
;;;; 
;;;;         sg_apply_viewport[f]
;;;;         sg_apply_scissor_rect[f]
;;;;         sg_draw
;;;; 
;;;;     The following function may be called inside a render- or compute-pass, but
;;;;     not outside a pass:
;;;; 
;;;;         sg_apply_pipeline
;;;;         sg_apply_bindings
;;;;         sg_apply_uniforms
;;;; 
;;;;     A frame must have at least one 'swapchain render pass' which renders into an
;;;;     externally provided swapchain provided as an sg_swapchain struct to the
;;;;     sg_begin_pass() function. If you use sokol_gfx.h together with sokol_app.h,
;;;;     just call the sglue_swapchain() helper function in sokol_glue.h to
;;;;     provide the swapchain information. Otherwise the following information
;;;;     must be provided:
;;;; 
;;;;         - the color pixel-format of the swapchain's render surface
;;;;         - an optional depth/stencil pixel format if the swapchain
;;;;           has a depth/stencil buffer
;;;;         - an optional sample-count for MSAA rendering
;;;;         - NOTE: the above three values can be zero-initialized, in that
;;;;           case the defaults from the sg_environment struct will be used that
;;;;           had been passed to the sg_setup() function.
;;;;         - a number of backend specific objects:
;;;;             - GL/GLES3: just a GL framebuffer handle
;;;;             - D3D11:
;;;;                 - an ID3D11RenderTargetView for the rendering surface
;;;;                 - if MSAA is used, an ID3D11RenderTargetView as
;;;;                   MSAA resolve-target
;;;;                 - an optional ID3D11DepthStencilView for the
;;;;                   depth/stencil buffer
;;;;             - WebGPU
;;;;                 - a WGPUTextureView object for the rendering surface
;;;;                 - if MSAA is used, a WGPUTextureView object as MSAA resolve target
;;;;                 - an optional WGPUTextureView for the
;;;;             - Metal (NOTE that the roles of provided surfaces is slightly
;;;;               different in Metal than in D3D11 or WebGPU, notably, the
;;;;               CAMetalDrawable is either rendered to directly, or serves
;;;;               as MSAA resolve target):
;;;;                 - a CAMetalDrawable object which is either rendered
;;;;                   into directly, or in case of MSAA rendering, serves
;;;;                   as MSAA-resolve-target
;;;;                 - if MSAA is used, an multisampled MTLTexture where
;;;;                   rendering goes into
;;;;                 - an optional MTLTexture for the depth/stencil buffer
;;;; 
;;;;     It's recommended that you create a helper function which returns an
;;;;     initialized sg_swapchain struct by value. This can then be directly plugged
;;;;     into the sg_begin_pass function like this:
;;;; 
;;;;         sg_begin_pass(&(sg_pass){ .swapchain = sglue_swapchain() });
;;;; 
;;;;     As an example for such a helper function check out the function sglue_swapchain()
;;;;     in the sokol_glue.h header.
;;;; 
;;;;     For offscreen render passes, the render target images used in a render pass
;;;;     must be provided as sg_view objects specialized for the specific pass-attachment
;;;;     types:
;;;; 
;;;;         - color-attachment-views for color-rendering
;;;;         - depth-stencil-attachment-views for the depth-stencil-buffer surface
;;;;         - resolve-attachment-views for MSAA-resolve operations
;;;; 
;;;;     For a simple offscreen scenario with one color-, one depth-stencil-render
;;;;     target and without multisampling, setting up the required image-
;;;;     and view-objects looks like this:
;;;; 
;;;;     First create two render target images, one with a color pixel format,
;;;;     and one with the depth- or depth-stencil pixel format. Both images
;;;;     must have the same dimensions. Also not the usage flags:
;;;; 
;;;;         const sg_image color_img = sg_make_image(&(sg_image_desc){
;;;;             .usage.color_attachment = true,
;;;;             .width = 256,
;;;;             .height = 256,
;;;;             .pixel_format = SG_PIXELFORMAT_RGBA8,
;;;;             .sample_count = 1,
;;;;         });
;;;;         const sg_image depth_img = sg_make_image(&(sg_image_desc){
;;;;             .usage.depth_stencil_attachment = true,
;;;;             .width = 256,
;;;;             .height = 256,
;;;;             .pixel_format = SG_PIXELFORMAT_DEPTH,
;;;;             .sample_count = 1,
;;;;         });
;;;; 
;;;;     NOTE: when creating render target images, have in mind that some default values
;;;;     are aligned with the default environment attributes in the sg_environment struct
;;;;     that was passed into the sg_setup() call:
;;;; 
;;;;         - the default value for sg_image_desc.pixel_format is taken from
;;;;           sg_environment.defaults.color_format
;;;;         - the default value for sg_image_desc.sample_count is taken from
;;;;           sg_environment.defaults.sample_count
;;;;         - the default value for sg_image_desc.num_mipmaps is always 1
;;;; 
;;;;     Next, create two view objects, one color-attachment-view and one
;;;;     depth-stencil-attachment view:
;;;; 
;;;;         const sg_view color_att_view = sg_make_view(&(sg_view_desc){
;;;;             .color_attachment.image = color_img,
;;;;         });
;;;;         const sg_view depth_att_view = sg_make_view(&(sg_view_desc){
;;;;             .depth_stencil_attachment.image = depth_img,
;;;;         });
;;;; 
;;;;     You'll typically also want to create a texture-view on the color image
;;;;     to sample the color attachment image as texture in a later pass:
;;;; 
;;;;         const sg_view tex_view = sg_make_view(&(sg_view_desc){
;;;;             .texture.image = color_img,
;;;;         });
;;;; 
;;;;     The attachment-view objects are then passed into the sg_begin_pass function in
;;;;     place of the nested swapchain struct:
;;;; 
;;;;         sg_begin_pass(&(sg_pass){
;;;;             .attachments = {
;;;;                 .colors[0] = color_att_view,
;;;;                 .depth_stencil = depth_att_view,
;;;;             },
;;;;         });
;;;; 
;;;;     ...in a later pass when you want to sample the color attachment image as
;;;;     texture, use the texture view in the sg_apply_bindings() call:
;;;; 
;;;;         sg_apply_bindings(&(sg_bindings){
;;;;             .vertex_buffers[0] = ...,
;;;;             .index_buffer = ...,
;;;;             .views[VIEW_tex] = tex_view,
;;;;             .samplers[SMP_smp] = smp,
;;;;         });
;;;; 
;;;;     Swapchain and offscreen passes form dependency trees with a swapchain
;;;;     pass at the root, offscreen passes as nodes, and attachment images as
;;;;     dependencies between passes.
;;;; 
;;;;     sg_pass_action structs are used to define actions that should happen at the
;;;;     start and end of render passes (such as clearing pass attachments to a
;;;;     specific color or depth-value, or performing an MSAA resolve operation at
;;;;     the end of a pass).
;;;; 
;;;;     A typical sg_pass_action object which clears the color attachment to black
;;;;     might look like this:
;;;; 
;;;;         const sg_pass_action = {
;;;;             .colors[0] = {
;;;;                 .load_action = SG_LOADACTION_CLEAR,
;;;;                 .clear_value = { 0.0f, 0.0f, 0.0f, 1.0f }
;;;;             }
;;;;         };
;;;; 
;;;;     This omits the defaults for the color attachment store action, and
;;;;     the depth-stencil-attachments actions. The same pass action with the
;;;;     defaults explicitly filled in would look like this:
;;;; 
;;;;         const sg_pass_action pass_action = {
;;;;             .colors[0] = {
;;;;                 .load_action = SG_LOADACTION_CLEAR,
;;;;                 .store_action = SG_STOREACTION_STORE,
;;;;                 .clear_value = { 0.0f, 0.0f, 0.0f, 1.0f }
;;;;             },
;;;;             .depth = = {
;;;;                 .load_action = SG_LOADACTION_CLEAR,
;;;;                 .store_action = SG_STOREACTION_DONTCARE,
;;;;                 .clear_value = 1.0f,
;;;;             },
;;;;             .stencil = {
;;;;                 .load_action = SG_LOADACTION_CLEAR,
;;;;                 .store_action = SG_STOREACTION_DONTCARE,
;;;;                 .clear_value = 0
;;;;             }
;;;;         };
;;;; 
;;;;     With the sg_pass object and sg_pass_action struct in place everything
;;;;     is ready now for the actual render pass:
;;;; 
;;;;     Using such this prepared sg_pass_action in a swapchain pass looks like
;;;;     this:
;;;; 
;;;;         sg_begin_pass(&(sg_pass){
;;;;             .action = pass_action,
;;;;             .swapchain = sglue_swapchain()
;;;;         });
;;;;         ...
;;;;         sg_end_pass();
;;;; 
;;;;     ...of alternatively in one offscreen pass:
;;;; 
;;;;         sg_begin_pass(&(sg_pass){
;;;;             .action = pass_action,
;;;;             .attachments = {
;;;;                 .colors[0] = color_att_view,
;;;;                 .depth_stencil = ds_att_view,
;;;;             },
;;;;         });
;;;;         ...
;;;;         sg_end_pass();
;;;; 
;;;;     Offscreen rendering can also go into a mipmap, or a slice/face of
;;;;     a cube-, array- or 3d-image (which some restrictions, for instance
;;;;     it's not possible to create a 3D image with a depth/stencil pixel format,
;;;;     these exceptions are generally caught by the sokol-gfx validation layer).
;;;; 
;;;;     The mipmap/slice selection is baked into the attachment-view objects, for
;;;;     instance to create a color-attachment-view for rendering into mip-level
;;;;     2 and slice 3 of an array texture:
;;;; 
;;;;         const sg_view color_att_view = sg_make_view(&(sg_view_desc){
;;;;             .color_attachment = {
;;;;                 .image = color_img,
;;;;                 .mip_level = 2,
;;;;                 .slice = 3,
;;;;             },
;;;;         });
;;;; 
;;;;     If MSAA offscreen rendering is desired, the multi-sample rendering result
;;;;     must be 'resolved' into a separate 'resolve image', before that image can
;;;;     be used as texture.
;;;; 
;;;;     Setting up MSAA offscreen 3D rendering requires three image objects
;;;;     (one color-attachment image with a sample count > 1), a resolve-attachment
;;;;     image with a sample count of 1, and a depth-stencil-attachment image
;;;;     with the same sample count as the color-attachment image:
;;;; 
;;;;         const sg_image color_img = sg_make_image(&(sg_image_desc){
;;;;             .usage.color_attachment = true,
;;;;             .width = 256,
;;;;             .height = 256,
;;;;             .pixel_format = SG_PIXELFORMAT_RGBA8,
;;;;             .sample_count = 4,
;;;;         });
;;;;         const sg_image resolve_img = sg_make_image(&(sg_image_desc){
;;;;             .usage.resolve_attachment = true,
;;;;             .width = 256,
;;;;             .height = 256,
;;;;             .pixel_format = SG_PIXELFORMAT_RGBA8,
;;;;             .sample_count = 1,
;;;;         });
;;;;         const sg_image depth_img = sg_make_image(&(sg_image_desc){
;;;;             .usage.depth_stencil_attachment = true,
;;;;             .width = 256,
;;;;             .height = 256,
;;;;             .pixel_format = SG_PIXELFORMAT_DEPTH,
;;;;             .sample_count = 4,
;;;;         });
;;;; 
;;;;     Next you'll need the corresponding attachment-view objects:
;;;; 
;;;;         const sg_view color_att_view = sg_make_view(&(sg_view_desc){
;;;;             .color_attachment.image = color_img,
;;;;         });
;;;;         const sg_view resolve_att_view = sg_make_view(&(sg_view_desc){
;;;;             .resolve_attachment.image = resolve_img,
;;;;         });
;;;;         const sg_view depth_att_view = sg_make_view(&(sg_view_desc){
;;;;             .depth_stencil_attachment.image = depth_img,
;;;;         });
;;;; 
;;;;     To sample the rendered image as a texture in a later pass you'll also
;;;;     need a texture-view on the resolve-attachment-image (not the color-attachment-image!):
;;;; 
;;;;         const sg_view tex_view = sg_make_view(&(sg_view_desc){
;;;;             .texture.image = resolve_img,
;;;;         });
;;;; 
;;;;     Next start the render pass with all attachment-views, as soon as a
;;;;     resolve-attachment-view is provided, an MSAA resolve operation will happen
;;;;     at the end of the pass. Also note that the content of the MSAA color-attachment-image
;;;;     doesn't need to be preserved, since it's only needed until the MSAA-resolve
;;;;     at the end of the pass, so the .store_action should be set to "don't care":
;;;; 
;;;;         sg_begin_pass(&(sg_pass){
;;;;             .attachments = {
;;;;                 .colors[0] = color_att_view,
;;;;                 .resolves[0] = resolve_att_view,
;;;;                 .depth_stencil = depth_att_view,
;;;;             },
;;;;             .action = {
;;;;                 .colors[0] = {
;;;;                     .load_action = SG_LOADACTION_CLEAR,
;;;;                     .store_action = SG_STOREACTION_DONTCARE,
;;;;                     .clear_value = { 0.0f, 0.0f, 0.0f, 1.0f },
;;;;                 }
;;;;             },
;;;;         });
;;;; 
;;;;     ...in a later pass, use the texture-view that had been created on the
;;;;     resolve-image to use the rendering result as texture:
;;;; 
;;;;         sg_apply_bindings(&(sg_bindings){
;;;;             .vertex_buffers[0] = ...,
;;;;             .index_buffer = ...,
;;;;             .views[VIEW_tex] = tex_view,
;;;;             .samplers[SMP_smp] = smp,
;;;;         });
;;;; 
;;;;     ON COMPUTE PASSES
;;;;     =================
;;;;     Compute passes are used to update the content of storage buffers and
;;;;     storage images by running compute shader code on
;;;;     the GPU. Updating storage resources with a compute shader will almost always
;;;;     be more efficient than computing the same data on the CPU and then uploading
;;;;     it via `sg_update_buffer()` or `sg_update_image()`.
;;;; 
;;;;     NOTE: compute passes are only supported on the following platforms and
;;;;     backends:
;;;; 
;;;;         - macOS and iOS with Metal
;;;;         - Windows with D3D11 and OpenGL
;;;;         - Linux with OpenGL or GLES3.1+
;;;;         - Web with WebGPU
;;;;         - Android with GLES3.1+
;;;; 
;;;;     ...this means compute shaders can't be used on the following platform/backend
;;;;     combos (the same restrictions apply to using storage buffers without compute
;;;;     shaders):
;;;; 
;;;;         - macOS with GL
;;;;         - iOS with GLES3
;;;;         - Web with WebGL2
;;;; 
;;;;     A compute pass is started with:
;;;; 
;;;;         sg_begin_pass(&(sg_pass){ .compute = true });
;;;; 
;;;;     ...and finished with a regular:
;;;; 
;;;;         sg_end_pass();
;;;; 
;;;;     Typically the following functions will be called inside a compute pass:
;;;; 
;;;;         sg_apply_pipeline()
;;;;         sg_apply_bindings()
;;;;         sg_apply_uniforms()
;;;;         sg_dispatch()
;;;; 
;;;;     The following functions are disallowed inside a compute pass
;;;;     and will cause validation layer errors:
;;;; 
;;;;         sg_apply_viewport[f]()
;;;;         sg_apply_scissor_rect[f]()
;;;;         sg_draw()
;;;; 
;;;;     Only special 'compute shaders' and 'compute pipelines' can be used in
;;;;     compute passes. A compute shader only has a compute-function instead
;;;;     of a vertex- and fragment-function pair, and it doesn't accept vertex-
;;;;     and index-buffers as bindings, only storage-buffer-views (readable
;;;;     and writable), storage-image-views (read/write or writeonly) and
;;;;     texture-views (read-only).
;;;; 
;;;;     A compute pipeline is created by providing a compute shader object,
;;;;     setting the .compute creation parameter to true and not defining any
;;;;     'render state':
;;;; 
;;;;         sg_pipeline pip = sg_make_pipeline(&(sg_pipeline_desc){
;;;;             .compute = true,
;;;;             .shader = compute_shader,
;;;;         });
;;;; 
;;;;     The sg_apply_bindings and sg_apply_uniforms calls are the same as in
;;;;     render passes, with the exception that no vertex- and index-buffers
;;;;     can be bound in the sg_apply_bindings call.
;;;; 
;;;;     Finally to kick off a compute workload, call sg_dispatch with the
;;;;     number of workgroups in the x, y and z-dimension:
;;;; 
;;;;         sg_dispatch(int num_groups_x, int num_groups_y, int num_groups_z)
;;;; 
;;;;     Also see the following compute-shader samples:
;;;; 
;;;;         - https://floooh.github.io/sokol-webgpu/instancing-compute-sapp.html
;;;;         - https://floooh.github.io/sokol-webgpu/computeboids-sapp.html
;;;;         - https://floooh.github.io/sokol-webgpu/imageblur-sapp.html
;;;; 
;;;; 
;;;;     ON SHADER CREATION
;;;;     ==================
;;;;     sokol-gfx doesn't come with an integrated shader cross-compiler, instead
;;;;     backend-specific shader sources or binary blobs need to be provided when
;;;;     creating a shader object, along with reflection information about the
;;;;     shader resource binding interface needed to bind sokol-gfx resources to the
;;;;     proper shader inputs.
;;;; 
;;;;     The easiest way to provide all this shader creation data is to use the
;;;;     sokol-shdc shader compiler tool to compile shaders from a common
;;;;     GLSL syntax into backend-specific sources or binary blobs, along with
;;;;     shader interface information and uniform blocks and storage buffer array items
;;;;     mapped to C structs.
;;;; 
;;;;     To create a shader using a C header which has been code-generated by sokol-shdc:
;;;; 
;;;;         // include the C header code-generated by sokol-shdc:
;;;;         #include "myshader.glsl.h"
;;;;         ...
;;;; 
;;;;         // create shader using a code-generated helper function from the C header:
;;;;         sg_shader shd = sg_make_shader(myshader_shader_desc(sg_query_backend()));
;;;; 
;;;;     The samples in the 'sapp' subdirectory of the sokol-samples project
;;;;     also use the sokol-shdc approach:
;;;; 
;;;;         https://github.com/floooh/sokol-samples/tree/master/sapp
;;;; 
;;;;     If you're planning to use sokol-shdc, you can stop reading here, instead
;;;;     continue with the sokol-shdc documentation:
;;;; 
;;;;         https://github.com/floooh/sokol-tools/blob/master/docs/sokol-shdc.md
;;;; 
;;;;     To create shaders with backend-specific shader code or binary blobs,
;;;;     the sg_make_shader() function requires the following information:
;;;; 
;;;;     - Shader code or shader binary blobs for the vertex- and fragment-, or the
;;;;       compute-shader-stage:
;;;;         - for the desktop GL backend, source code can be provided in '#version 410' or
;;;;           '#version 430', version 430 is required when using storage buffers and
;;;;           compute shaders, but note that this is not available on macOS
;;;;         - for the GLES3 backend, source code must be provided in '#version 300 es' or
;;;;           '#version 310 es' syntax (version 310 is required for storage buffer and
;;;;           compute shader support, but note that this is not supported on WebGL2)
;;;;         - for the D3D11 backend, shaders can be provided as source or binary
;;;;           blobs, the source code should be in HLSL4.0 (for compatibility with old
;;;;           low-end GPUs) or preferably in HLSL5.0 syntax, note that when
;;;;           shader source code is provided for the D3D11 backend, sokol-gfx will
;;;;           dynamically load 'd3dcompiler_47.dll'
;;;;         - for the Metal backends, shaders can be provided as source or binary blobs, the
;;;;           MSL version should be in 'metal-1.1' (other versions may work but are not tested)
;;;;         - for the WebGPU backend, shaders must be provided as WGSL source code
;;;;         - optionally the following shader-code related attributes can be provided:
;;;;             - an entry function name (only on D3D11 or Metal, but not OpenGL)
;;;;             - on D3D11 only, a compilation target (default is "vs_4_0" and "ps_4_0")
;;;; 
;;;;     - Information about the input vertex attributes used by the vertex shader,
;;;;       most of that backend-specific:
;;;;         - An optional 'base type' (float, signed-/unsigned-int) for each vertex
;;;;           attribute. When provided, this is used by the validation layer to check
;;;;           that the CPU-side input vertex format is compatible with the input
;;;;           vertex declaration of the vertex shader.
;;;;         - Metal: no location information needed since vertex attributes are always bound
;;;;           by their attribute location defined in the shader via '[[attribute(N)]]'
;;;;         - WebGPU: no location information needed since vertex attributes are always
;;;;           bound by their attribute location defined in the shader via `@location(N)`
;;;;         - GLSL: vertex attribute names can be optionally provided, in that case their
;;;;           location will be looked up by name, otherwise, the vertex attribute location
;;;;           can be defined with 'layout(location = N)'
;;;;         - D3D11: a 'semantic name' and 'semantic index' must be provided for each vertex
;;;;           attribute, e.g. if the vertex attribute is defined as 'TEXCOORD1' in the shader,
;;;;           the semantic name would be 'TEXCOORD', and the semantic index would be '1'
;;;; 
;;;;       NOTE that vertex attributes currently must not have gaps. This requirement
;;;;       may be relaxed in the future.
;;;; 
;;;;     - Specifically for Metal compute shaders, the 'number of threads per threadgroup'
;;;;       must be provided. Normally this is extracted by sokol-shdc from the GLSL
;;;;       shader source code. For instance the following statement in the input
;;;;       GLSL:
;;;; 
;;;;         layout(local_size_x=64, local_size_y=1, local_size_z=1) in;
;;;; 
;;;;       ...will be communicated to the sokol-gfx Metal backend in the
;;;;       code-generated sg_shader_desc struct:
;;;; 
;;;;         (sg_shader_desc){
;;;;             .mtl_threads_per_threadgroup = { .x = 64, .y = 1, .z = 1 },
;;;;         }
;;;; 
;;;;     - Information about each uniform block binding used in the shader:
;;;;         - the shader stage of the uniform block (vertex, fragment or compute)
;;;;         - the size of the uniform block in number of bytes
;;;;         - a memory layout hint (currently 'native' or 'std140') where 'native' defines a
;;;;           backend-specific memory layout which shouldn't be used for cross-platform code.
;;;;           Only std140 guarantees a backend-agnostic memory layout.
;;;;         - a backend-specific bind slot:
;;;;             - D3D11/HLSL: the buffer register N (`register(bN)`) where N is 0..7
;;;;             - Metal/MSL: the buffer bind slot N (`[[buffer(N)]]`) where N is 0..7
;;;;             - WebGPU: the binding N in `@group(0) @binding(N)` where N is 0..15
;;;;         - For GLSL only: a description of the internal uniform block layout, which maps
;;;;           member types and their offsets on the CPU side to uniform variable names
;;;;           in the GLSL shader
;;;;         - please also NOTE the documentation sections about UNIFORM DATA LAYOUT
;;;;           and CROSS-BACKEND COMMON UNIFORM DATA LAYOUT below!
;;;; 
;;;;     - A description of each resource binding (texture-, storage-buffer-
;;;;       and storage-image-bindings) which directly map to the sg_bindings.view[]
;;;;       array slots.
;;;; 
;;;;       Each resource binding slot comes in three flavours:
;;;; 
;;;;         1. Texture bindings with the following properties:
;;;;             - the shader stage of the texture (vertex, fragment or compute)
;;;;             - the expected image type:
;;;;                 - SG_IMAGETYPE_2D
;;;;                 - SG_IMAGETYPE_CUBE
;;;;                 - SG_IMAGETYPE_3D
;;;;                 - SG_IMAGETYPE_ARRAY
;;;;             - the expected 'image sample type':
;;;;                 - SG_IMAGESAMPLETYPE_FLOAT
;;;;                 - SG_IMAGESAMPLETYPE_DEPTH
;;;;                 - SG_IMAGESAMPLETYPE_SINT
;;;;                 - SG_IMAGESAMPLETYPE_UINT
;;;;                 - SG_IMAGESAMPLETYPE_UNFILTERABLE_FLOAT
;;;;             - a flag whether the texture is expected to be multisampled
;;;;             - a backend-specific bind slot:
;;;;                 - D3D11/HLSL: the texture register N (`register(tN)`) where N is 0..31
;;;;                 (in HLSL, readonly storage buffers and texture share the same bind space)
;;;;                 - Metal/MSL: the texture bind slot N (`[[texture(N)]]`) where N is 0..31
;;;;                 (the bind slot must not collide with storage image bindings on the same stage)
;;;;                 - WebGPU/WGSL: the binding N in `@group(0) @binding(N)` where N is 0..127
;;;; 
;;;;         2. Storage buffer bindings with the following properties:
;;;;             - the shader stage of the storage buffer
;;;;             - a boolean 'readonly' flag, this is used for validation and hazard
;;;;             tracking in some 3D backends. Note that in render passes, only
;;;;             readonly storage buffer bindings are allowed. In compute passes, any
;;;;             read/write storage buffer binding is assumed to be written to by the
;;;;             compute shader.
;;;;             - a backend-specific bind slot:
;;;;                 - D3D11/HLSL:
;;;;                     - for readonly storage buffer bindings: the texture register N
;;;;                     (`register(tN)`) where N is 0..31 (in HLSL, readonly storage
;;;;                     buffers and textures share the same bind space for
;;;;                     'shader resource views')
;;;;                     - for read/write storage buffer buffer bindings: the UAV register N
;;;;                     (`register(uN)`) where N is 0..31 (in HLSL, readwrite storage
;;;;                     buffers use their own bind space for 'unordered access views')
;;;;                 - Metal/MSL: the buffer bind slot N (`[[buffer(N)]]`) where N is 8..23
;;;;                 - WebGPU/WGSL: the binding N in `@group(0) @binding(N)` where N is 0..127
;;;;                 - GL/GLSL: the buffer binding N in `layout(binding=N)`
;;;;                   where N is 0..sg_limits.max_storage_buffer_bindings_per_stage
;;;;             - note that storage buffer bindings are not supported on all backends
;;;;             and platforms
;;;; 
;;;;         3. Storage image bindings with the following properties:
;;;;             - the shader stage (*must* be compute)
;;;;             - the expected image type:
;;;;                 - SG_IMAGETYPE_2D
;;;;                 - SG_IMAGETYPE_CUBE
;;;;                 - SG_IMAGETYPE_3D
;;;;                 - SG_IMAGETYPE_ARRAY
;;;;             - the 'access pixel format', this is currently limited to:
;;;;                 - SG_PIXELFORMAT_RGBA8
;;;;                 - SG_PIXELFORMAT_RGBA8SN/UI/SI
;;;;                 - SG_PIXELFORMAT_RGBA16UI/SI/F
;;;;                 - SG_PIXELFORMAT_R32UIUI/SI/F
;;;;                 - SG_PIXELFORMAT_RG32UI/SI/F
;;;;                 - SG_PIXELFORMAT_RGBA32UI/SI/F
;;;;             - the access type (readwrite or writeonly)
;;;;             - a backend-specific bind slot:
;;;;                 - D3D11/HLSL: the UAV register N (`register(uN)` where N is 0..31, the
;;;;                 bind slot must not collide with UAV storage buffer bindings
;;;;                 - Metal/MSL: the texture bind slot N (`[[texture(N)]])` where N is 0..31,
;;;;                 the bind slot must not collide with other texture bindings on the same
;;;;                 stage
;;;;                 - WebGPU/WGSL: the binding N in `@group(1) @binding(N)` where N is 0..127
;;;;                 - GL/GLSL: the buffer binding N in `layout(binding=N)`
;;;;                   where N is 0.._sg.max_storage_image_bindings_per_stage
;;;;             - note that storage image bindings are not supported on all backends and platforms
;;;; 
;;;;     - A description of each sampler used in the shader:
;;;;         - the shader stage of the sampler (vertex, fragment or compute)
;;;;         - the expected sampler type:
;;;;             - SG_SAMPLERTYPE_FILTERING,
;;;;             - SG_SAMPLERTYPE_NONFILTERING,
;;;;             - SG_SAMPLERTYPE_COMPARISON,
;;;;         - a backend-specific bind slot:
;;;;             - D3D11/HLSL: the sampler register N (`register(sN)`) where N is 0..SG_MAX_SAMPLER_BINDINGS
;;;;             - Metal/MSL: the sampler bind slot N (`[[sampler(N)]]`) where N is 0..SG_MAX_SAMPLER_BINDINGS
;;;;             - WebGPU/WGSL: the binding N in `@group(0) @binding(N)` where N is 0..127
;;;; 
;;;;     - An array of 'texture-sampler-pairs' used by the shader to sample textures,
;;;;       for D3D11, Metal and WebGPU this is used for validation purposes to check
;;;;       whether the texture and sampler are compatible with each other (especially
;;;;       WebGPU is very picky about combining the correct
;;;;       texture-sample-type with the correct sampler-type). For GLSL an
;;;;       additional 'combined-image-sampler name' must be provided because 'OpenGL
;;;;       style GLSL' cannot handle separate texture and sampler objects, but still
;;;;       groups them into a traditional GLSL 'sampler object'.
;;;; 
;;;;     Compatibility rules for image-sample-type vs sampler-type are as follows:
;;;; 
;;;;         - SG_IMAGESAMPLETYPE_FLOAT => (SG_SAMPLERTYPE_FILTERING or SG_SAMPLERTYPE_NONFILTERING)
;;;;         - SG_IMAGESAMPLETYPE_UNFILTERABLE_FLOAT => SG_SAMPLERTYPE_NONFILTERING
;;;;         - SG_IMAGESAMPLETYPE_SINT => SG_SAMPLERTYPE_NONFILTERING
;;;;         - SG_IMAGESAMPLETYPE_UINT => SG_SAMPLERTYPE_NONFILTERING
;;;;         - SG_IMAGESAMPLETYPE_DEPTH => SG_SAMPLERTYPE_COMPARISON
;;;; 
;;;;     Backend-specific bindslot ranges (not relevant when using sokol-shdc):
;;;; 
;;;;         - D3D11/HLSL:
;;;;             - separate bindslot space per shader stage
;;;;             - uniform block bindings (as cbuffer): `register(b0..b7)`
;;;;             - texture- and readonly storage buffer bindings: `register(t0..t31)`
;;;;             - read/write storage buffer and storage image bindings: `register(u0..u31)`
;;;;             - samplers: `register(s0..s11)`
;;;;         - Metal/MSL:
;;;;             - separate bindslot space per shader stage
;;;;             - uniform blocks: `[[buffer(0..7)]]`
;;;;             - storage buffers: `[[buffer(8..23)]]`
;;;;             - textures and storage image bindings: `[[texture(0..31)]]`
;;;;             - samplers: `[[sampler(0..11)]]`
;;;;         - WebGPU/WGSL:
;;;;             - common bindslot space across shader stages
;;;;             - uniform blocks: `@group(0) @binding(0..15)`
;;;;             - textures, storage-images, storage-buffers and sampler: `@group(1) @binding(0..127)`
;;;;         - GL/GLSL:
;;;;             - uniforms and image-samplers are bound by name
;;;;             - storage buffer bindings: `layout(std430, binding=0..sg_limits.max_storage_buffer_bindings_per_stage` (common
;;;;               bindslot space across shader stages)
;;;;             - storage image bindings: `layout(binding=0..sg_limits.max_storage_image_bindings_per_stage, [access_format])`
;;;; 
;;;;     For example code of how to create backend-specific shader objects,
;;;;     please refer to the following samples:
;;;; 
;;;;         - for D3D11:    https://github.com/floooh/sokol-samples/tree/master/d3d11
;;;;         - for Metal:    https://github.com/floooh/sokol-samples/tree/master/metal
;;;;         - for OpenGL:   https://github.com/floooh/sokol-samples/tree/master/glfw
;;;;         - for GLES3:    https://github.com/floooh/sokol-samples/tree/master/html5
;;;;         - for WebGPU:   https://github.com/floooh/sokol-samples/tree/master/wgpu
;;;; 
;;;; 
;;;;     ON SG_IMAGESAMPLETYPE_UNFILTERABLE_FLOAT AND SG_SAMPLERTYPE_NONFILTERING
;;;;     ========================================================================
;;;;     The WebGPU backend introduces the concept of 'unfilterable-float' textures,
;;;;     which can only be combined with 'nonfiltering' samplers (this is a restriction
;;;;     specific to WebGPU, but since the same sokol-gfx code should work across
;;;;     all backend, the sokol-gfx validation layer also enforces this restriction
;;;;     - the alternative would be undefined behaviour in some backend APIs on
;;;;     some devices).
;;;; 
;;;;     The background is that some mobile devices (most notably iOS devices) can
;;;;     not perform linear filtering when sampling textures with certain pixel
;;;;     formats, most notable the 32F formats:
;;;; 
;;;;         - SG_PIXELFORMAT_R32F
;;;;         - SG_PIXELFORMAT_RG32F
;;;;         - SG_PIXELFORMAT_RGBA32F
;;;; 
;;;;     The information of whether a shader is going to be used with such an
;;;;     unfilterable-float texture must already be provided in the sg_shader_desc
;;;;     struct when creating the shader (see the above section "ON SHADER CREATION").
;;;; 
;;;;     If you are using the sokol-shdc shader compiler, the information whether a
;;;;     texture/sampler binding expects an 'unfilterable-float/nonfiltering'
;;;;     texture/sampler combination cannot be inferred from the shader source
;;;;     alone, you'll need to provide this hint via annotation-tags. For instance
;;;;     here is an example from the ozz-skin-sapp.c sample shader which samples an
;;;;     RGBA32F texture with skinning matrices in the vertex shader:
;;;; 
;;;;     ```glsl
;;;;     @image_sample_type joint_tex unfilterable_float
;;;;     uniform texture2D joint_tex;
;;;;     @sampler_type smp nonfiltering
;;;;     uniform sampler smp;
;;;;     ```
;;;; 
;;;;     This will result in SG_IMAGESAMPLETYPE_UNFILTERABLE_FLOAT and
;;;;     SG_SAMPLERTYPE_NONFILTERING being written to the code-generated
;;;;     sg_shader_desc struct.
;;;; 
;;;; 
;;;;     ON VERTEX FORMATS
;;;;     =================
;;;;     Sokol-gfx implements the same strict mapping rules from CPU-side
;;;;     vertex component formats to GPU-side vertex input data types:
;;;; 
;;;;     - float and packed normalized CPU-side formats must be used as
;;;;       floating point base type in the vertex shader
;;;;     - packed signed-integer CPU-side formats must be used as signed
;;;;       integer base type in the vertex shader
;;;;     - packed unsigned-integer CPU-side formats must be used as unsigned
;;;;       integer base type in the vertex shader
;;;; 
;;;;     These mapping rules are enforced by the sokol-gfx validation layer,
;;;;     but only when sufficient reflection information is provided in
;;;;     `sg_shader_desc.attrs[].base_type`. This is the case when sokol-shdc
;;;;     is used, otherwise the default base_type will be SG_SHADERATTRBASETYPE_UNDEFINED
;;;;     which causes the sokol-gfx validation check to be skipped (of course you
;;;;     can also provide the per-attribute base type information manually when
;;;;     not using sokol-shdc).
;;;; 
;;;;     The detailed mapping rules from SG_VERTEXFORMAT_* to GLSL data types
;;;;     are as follows:
;;;; 
;;;;     - FLOAT[*] => float, vec*
;;;;     - BYTE4N => vec* (scaled to -1.0 .. +1.0)
;;;;     - UBYTE4N => vec* (scaled to 0.0 .. +1.0)
;;;;     - SHORT[*]N => vec* (scaled to -1.0 .. +1.0)
;;;;     - USHORT[*]N => vec* (scaled to 0.0 .. +1.0)
;;;;     - INT[*] => int, ivec*
;;;;     - UINT[*] => uint, uvec*
;;;;     - BYTE4 => int*
;;;;     - UBYTE4 => uint*
;;;;     - SHORT[*] => int*
;;;;     - USHORT[*] => uint*
;;;; 
;;;;     NOTE that sokol-gfx only provides vertex formats with sizes of a multiple
;;;;     of 4 (e.g. BYTE4N but not BYTE2N). This is because vertex components must
;;;;     be 4-byte aligned anyway.
;;;; 
;;;; 
;;;;     UNIFORM DATA LAYOUT:
;;;;     ====================
;;;;     NOTE: if you use the sokol-shdc shader compiler tool, you don't need to worry
;;;;     about the following details.
;;;; 
;;;;     The data that's passed into the sg_apply_uniforms() function must adhere to
;;;;     specific layout rules so that the GPU shader finds the uniform block
;;;;     items at the right offset.
;;;; 
;;;;     For the D3D11 and Metal backends, sokol-gfx only cares about the size of uniform
;;;;     blocks, but not about the internal layout. The data will just be copied into
;;;;     a uniform/constant buffer in a single operation and it's up you to arrange the
;;;;     CPU-side layout so that it matches the GPU side layout. This also means that with
;;;;     the D3D11 and Metal backends you are not limited to a 'cross-platform' subset
;;;;     of uniform variable types.
;;;; 
;;;;     If you ever only use one of the D3D11, Metal *or* WebGPU backend, you can stop reading here.
;;;; 
;;;;     For the GL backends, the internal layout of uniform blocks matters though,
;;;;     and you are limited to a small number of uniform variable types. This is
;;;;     because sokol-gfx must be able to locate the uniform block members in order
;;;;     to upload them to the GPU with glUniformXXX() calls.
;;;; 
;;;;     To describe the uniform block layout to sokol-gfx, the following information
;;;;     must be passed to the sg_make_shader() call in the sg_shader_desc struct:
;;;; 
;;;;         - a hint about the used packing rule (either SG_UNIFORMLAYOUT_NATIVE or
;;;;           SG_UNIFORMLAYOUT_STD140)
;;;;         - a list of the uniform block members types in the correct order they
;;;;           appear on the CPU side
;;;; 
;;;;     For example if the GLSL shader has the following uniform declarations:
;;;; 
;;;;         uniform mat4 mvp;
;;;;         uniform vec2 offset0;
;;;;         uniform vec2 offset1;
;;;;         uniform vec2 offset2;
;;;; 
;;;;     ...and on the CPU side, there's a similar C struct:
;;;; 
;;;;         typedef struct {
;;;;             float mvp[16];
;;;;             float offset0[2];
;;;;             float offset1[2];
;;;;             float offset2[2];
;;;;         } params_t;
;;;; 
;;;;     ...the uniform block description in the sg_shader_desc must look like this:
;;;; 
;;;;         sg_shader_desc desc = {
;;;;             .vs.uniform_blocks[0] = {
;;;;                 .size = sizeof(params_t),
;;;;                 .layout = SG_UNIFORMLAYOUT_NATIVE,  // this is the default and can be omitted
;;;;                 .uniforms = {
;;;;                     // order must be the same as in 'params_t':
;;;;                     [0] = { .name = "mvp", .type = SG_UNIFORMTYPE_MAT4 },
;;;;                     [1] = { .name = "offset0", .type = SG_UNIFORMTYPE_VEC2 },
;;;;                     [2] = { .name = "offset1", .type = SG_UNIFORMTYPE_VEC2 },
;;;;                     [3] = { .name = "offset2", .type = SG_UNIFORMTYPE_VEC2 },
;;;;                 }
;;;;             }
;;;;         };
;;;; 
;;;;     With this information sokol-gfx can now compute the correct offsets of the data items
;;;;     within the uniform block struct.
;;;; 
;;;;     The SG_UNIFORMLAYOUT_NATIVE packing rule works fine if only the GL backends are used,
;;;;     but for proper D3D11/Metal/GL a subset of the std140 layout must be used which is
;;;;     described in the next section:
;;;; 
;;;; 
;;;;     CROSS-BACKEND COMMON UNIFORM DATA LAYOUT
;;;;     ========================================
;;;;     For cross-platform / cross-3D-backend code it is important that the same uniform block
;;;;     layout on the CPU side can be used for all sokol-gfx backends. To achieve this,
;;;;     a common subset of the std140 layout must be used:
;;;; 
;;;;     - The uniform block layout hint in sg_shader_desc must be explicitly set to
;;;;       SG_UNIFORMLAYOUT_STD140.
;;;;     - Only the following GLSL uniform types can be used (with their associated sokol-gfx enums):
;;;;         - float => SG_UNIFORMTYPE_FLOAT
;;;;         - vec2  => SG_UNIFORMTYPE_FLOAT2
;;;;         - vec3  => SG_UNIFORMTYPE_FLOAT3
;;;;         - vec4  => SG_UNIFORMTYPE_FLOAT4
;;;;         - int   => SG_UNIFORMTYPE_INT
;;;;         - ivec2 => SG_UNIFORMTYPE_INT2
;;;;         - ivec3 => SG_UNIFORMTYPE_INT3
;;;;         - ivec4 => SG_UNIFORMTYPE_INT4
;;;;         - mat4  => SG_UNIFORMTYPE_MAT4
;;;;     - Alignment for those types must be as follows (in bytes):
;;;;         - float => 4
;;;;         - vec2  => 8
;;;;         - vec3  => 16
;;;;         - vec4  => 16
;;;;         - int   => 4
;;;;         - ivec2 => 8
;;;;         - ivec3 => 16
;;;;         - ivec4 => 16
;;;;         - mat4  => 16
;;;;     - Arrays are only allowed for the following types: vec4, int4, mat4.
;;;; 
;;;;     Note that the HLSL cbuffer layout rules are slightly different from the
;;;;     std140 layout rules, this means that the cbuffer declarations in HLSL code
;;;;     must be tweaked so that the layout is compatible with std140.
;;;; 
;;;;     The by far easiest way to tackle the common uniform block layout problem is
;;;;     to use the sokol-shdc shader cross-compiler tool!
;;;; 
;;;; 
;;;;     ON STORAGE BUFFERS
;;;;     ==================
;;;;     The two main purpose of storage buffers are:
;;;; 
;;;;         - to be populated by compute shaders with dynamically generated data
;;;;         - for providing random-access data to all shader stages
;;;; 
;;;;     Storage buffers can be used to pass large amounts of random access structured
;;;;     data from the CPU side to the shaders. They are similar to data textures, but are
;;;;     more convenient to use both on the CPU and shader side since they can be accessed
;;;;     in shaders as as a 1-dimensional array of struct items.
;;;; 
;;;;     Storage buffers are *NOT* supported on the following platform/backend combos:
;;;; 
;;;;     - macOS+GL (because storage buffers require GL 4.3, while macOS only goes up to GL 4.1)
;;;;     - platforms which only support a GLES3.0 context (WebGL2 and iOS)
;;;; 
;;;;     To use storage buffers, the following steps are required:
;;;; 
;;;;         - write a shader which uses storage buffers (vertex- and fragment-shaders
;;;;           can only read from storage buffers, while compute-shaders can both read
;;;;           and write storage buffers)
;;;;         - create one or more storage buffers via sg_make_buffer() with the
;;;;           `.usage.storage_buffer = true`
;;;;         - when creating a shader via sg_make_shader(), populate the sg_shader_desc
;;;;           struct with binding info (when using sokol-shdc, this step will be taken care
;;;;           of automatically)
;;;;             - which storage buffer bind slots on the vertex-, fragment- or compute-stage
;;;;               are occupied
;;;;             - whether the storage buffer on that bind slot is readonly (readonly
;;;;               bindings are required for vertex- and fragment-shaders, and in compute
;;;;               shaders the readonly flag is used to control hazard tracking in some
;;;;               3D backends)
;;;; 
;;;;         - when calling sg_apply_bindings(), apply the matching bind slots with the previously
;;;;           created storage buffers
;;;;         - ...and that's it.
;;;; 
;;;;     For more details, see the following backend-agnostic sokol samples:
;;;; 
;;;;     - simple vertex pulling from a storage buffer:
;;;;         - C code: https://github.com/floooh/sokol-samples/blob/master/sapp/vertexpull-sapp.c
;;;;         - shader: https://github.com/floooh/sokol-samples/blob/master/sapp/vertexpull-sapp.glsl
;;;;     - instanced rendering via storage buffers (vertex- and instance-pulling):
;;;;         - C code: https://github.com/floooh/sokol-samples/blob/master/sapp/instancing-pull-sapp.c
;;;;         - shader: https://github.com/floooh/sokol-samples/blob/master/sapp/instancing-pull-sapp.glsl
;;;;     - storage buffers both on the vertex- and fragment-stage:
;;;;         - C code: https://github.com/floooh/sokol-samples/blob/master/sapp/sbuftex-sapp.c
;;;;         - shader: https://github.com/floooh/sokol-samples/blob/master/sapp/sbuftex-sapp.glsl
;;;;     - the Ozz animation sample rewritten to pull all rendering data from storage buffers:
;;;;         - C code: https://github.com/floooh/sokol-samples/blob/master/sapp/ozz-storagebuffer-sapp.cc
;;;;         - shader: https://github.com/floooh/sokol-samples/blob/master/sapp/ozz-storagebuffer-sapp.glsl
;;;;     - the instancing sample modified to use compute shaders:
;;;;         - C code: https://github.com/floooh/sokol-samples/blob/master/sapp/instancing-compute-sapp.c
;;;;         - shader: https://github.com/floooh/sokol-samples/blob/master/sapp/instancing-compute-sapp.glsl
;;;;     - the Compute Boids sample ported to sokol-gfx:
;;;;         - C code: https://github.com/floooh/sokol-samples/blob/master/sapp/computeboids-sapp.c
;;;;         - shader: https://github.com/floooh/sokol-samples/blob/master/sapp/computeboids-sapp.glsl
;;;; 
;;;;     ...also see the following backend-specific vertex pulling samples (those also don't use sokol-shdc):
;;;; 
;;;;     - D3D11: https://github.com/floooh/sokol-samples/blob/master/d3d11/vertexpulling-d3d11.c
;;;;     - desktop GL: https://github.com/floooh/sokol-samples/blob/master/glfw/vertexpulling-glfw.c
;;;;     - Metal: https://github.com/floooh/sokol-samples/blob/master/metal/vertexpulling-metal.c
;;;;     - WebGPU: https://github.com/floooh/sokol-samples/blob/master/wgpu/vertexpulling-wgpu.c
;;;; 
;;;;     ...and the backend specific compute shader samples:
;;;; 
;;;;     - D3D11: https://github.com/floooh/sokol-samples/blob/master/d3d11/instancing-compute-d3d11.c
;;;;     - desktop GL: https://github.com/floooh/sokol-samples/blob/master/glfw/instancing-compute-glfw.c
;;;;     - Metal: https://github.com/floooh/sokol-samples/blob/master/metal/instancing-compute-metal.c
;;;;     - WebGPU: https://github.com/floooh/sokol-samples/blob/master/wgpu/instancing-compute-wgpu.c
;;;; 
;;;;     Storage buffer shader authoring caveats when using sokol-shdc:
;;;; 
;;;;         - declare a read-only storage buffer interface block with `layout(binding=N) readonly buffer [name] { ... }`
;;;;           (where 'N' is the index in `sg_bindings.storage_buffers[N]`)
;;;;         - ...or a read/write storage buffer interface block with `layout(binding=N) buffer [name] { ... }`
;;;;         - declare a struct which describes a single array item in the storage buffer interface block
;;;;         - only put a single flexible array member into the storage buffer interface block
;;;; 
;;;;     E.g. a complete example in 'sokol-shdc GLSL':
;;;; 
;;;;         ```glsl
;;;;         @vs
;;;;         // declare a struct:
;;;;         struct sb_vertex {
;;;;             vec3 pos;
;;;;             vec4 color;
;;;;         }
;;;;         // declare a buffer interface block with a single flexible struct array:
;;;;         layout(binding=0) readonly buffer vertices {
;;;;             sb_vertex vtx[];
;;;;         }
;;;;         // in the shader function, access the storage buffer like this:
;;;;         void main() {
;;;;             vec3 pos = vtx[gl_VertexIndex].pos;
;;;;             ...
;;;;         }
;;;;         @end
;;;;         ```
;;;; 
;;;;     In a compute shader you can read and write the same item in the same
;;;;     storage buffer (but you'll have to be careful for random access since
;;;;     many threads of the same compute function run in parallel):
;;;; 
;;;;         @cs
;;;;         struct sb_item {
;;;;             vec3 pos;
;;;;             vec3 vel;
;;;;         }
;;;;         layout(binding=0) buffer items_ssbo {
;;;;             sb_item items[];
;;;;         }
;;;;         layout(local_size_x=64, local_size_y=1, local_size_z=1) in;
;;;;         void main() {
;;;;             uint idx = gl_GlobalInvocationID.x;
;;;;             vec3 pos = items[idx].pos;
;;;;             ...
;;;;             items[idx].pos = pos;
;;;;         }
;;;;         @end
;;;; 
;;;;     Backend-specific storage-buffer caveats (not relevant when using sokol-shdc):
;;;; 
;;;;         D3D11:
;;;;             - storage buffers are created as 'raw' Byte Address Buffers
;;;;               (https://learn.microsoft.com/en-us/windows/win32/direct3d11/overviews-direct3d-11-resources-intro#raw-views-of-buffers)
;;;;             - in HLSL, use a ByteAddressBuffer for readonly access of the buffer content:
;;;;               (https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/sm5-object-byteaddressbuffer)
;;;;             - ...or RWByteAddressBuffer for read/write access:
;;;;               (https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/sm5-object-rwbyteaddressbuffer)
;;;;             - readonly-storage buffers and textures are both bound as 'shader-resource-view' and
;;;;               share the same bind slots (declared as `register(tN)` in HLSL), where N must be in the range 0..23)
;;;;             - read/write storage buffers and storage images are bound as 'unordered-access-view'
;;;;               (declared as `register(uN)` in HLSL where N is in the range 0..11)
;;;; 
;;;;         Metal:
;;;;             - in Metal there is no internal difference between vertex-, uniform- and
;;;;               storage-buffers, all are bound to the same 'buffer bind slots' with the
;;;;               following reserved ranges:
;;;;                 - vertex shader stage:
;;;;                     - uniform buffers: slots 0..7
;;;;                     - storage buffers: slots 8..15
;;;;                     - vertex buffers: slots 15..23
;;;;                 - fragment shader stage:
;;;;                     - uniform buffers: slots 0..7
;;;;                     - storage buffers: slots 8..15
;;;;             - this means in MSL, storage buffer bindings start at [[buffer(8)]] both in
;;;;               the vertex and fragment stage
;;;; 
;;;;         GL:
;;;;             - the GL backend doesn't use name-lookup to find storage buffer bindings, this
;;;;               means you must annotate buffers with `layout(std430, binding=N)` in GLSL
;;;;             - ...where N is 0..sg_limits.max_storage_buffer_bindings_per_stage.
;;;; 
;;;;         WebGPU:
;;;;             - in WGSL, textures, samplers and storage buffers all use a shared
;;;;               bindspace across all shader stages on bindgroup 1:
;;;; 
;;;;               `@group(1) @binding(0..127)
;;;; 
;;;;     ON STORAGE IMAGES:
;;;;     ==================
;;;;     To write pixel data to texture objects in compute shaders, first an image
;;;;     object must be created with `storage_image usage`:
;;;; 
;;;;         sg_image storage_image = sg_make_image(&(sg_image_desc){
;;;;             .usage.storage_image = true,
;;;;             },
;;;;             .width = ...,
;;;;             .height = ...,
;;;;             .pixel_format = ...,
;;;;         });
;;;; 
;;;;     Next a storage-image-view object is required which also allows to pick
;;;;     a specific mip-level or slice for the compute-shader to access:
;;;; 
;;;;         sg_view simg_view = sg_make_view(&(sg_view_desc){
;;;;             .storage_image = {
;;;;                 .image = storage_image,
;;;;                 .mip_level = ...,
;;;;                 .slice = ...
;;;;             },
;;;;         });
;;;; 
;;;;     Finally 'bind' the storage-image-view via a regular sg_apply_bindings() call
;;;;     inside a compute pass:
;;;; 
;;;;         sg_begin_pass(&(sg_pass){ .compute = true });
;;;;         sg_apply_pipeline(...);
;;;;         sg_apply_bindings(&(sg_bindings){
;;;;             .views[VIEW_simg] = simg_view,
;;;;         });
;;;;         sg_dispatch(...);
;;;;         sg_end_pass();
;;;; 
;;;;     Currently, storage images can only be used with `readwrite` or `writeonly` access in
;;;;     shaders. For readonly access use a regular texture binding instead.
;;;; 
;;;;     For an example of using storage images in compute shaders see imageblur-sapp:
;;;; 
;;;;         - C code: https://github.com/floooh/sokol-samples/blob/master/sapp/imageblur-sapp.c
;;;;         - shader: https://github.com/floooh/sokol-samples/blob/master/sapp/imageblur-sapp.glsl
;;;; 
;;;;     TRACE HOOKS:
;;;;     ============
;;;;     sokol_gfx.h optionally allows to install "trace hook" callbacks for
;;;;     each public API functions. When a public API function is called, and
;;;;     a trace hook callback has been installed for this function, the
;;;;     callback will be invoked with the parameters and result of the function.
;;;;     This is useful for things like debugging- and profiling-tools, or
;;;;     keeping track of resource creation and destruction.
;;;; 
;;;;     To use the trace hook feature:
;;;; 
;;;;     --- Define SOKOL_TRACE_HOOKS before including the implementation.
;;;; 
;;;;     --- Setup an sg_trace_hooks structure with your callback function
;;;;         pointers (keep all function pointers you're not interested
;;;;         in zero-initialized), optionally set the user_data member
;;;;         in the sg_trace_hooks struct.
;;;; 
;;;;     --- Install the trace hooks by calling sg_install_trace_hooks(),
;;;;         the return value of this function is another sg_trace_hooks
;;;;         struct which contains the previously set of trace hooks.
;;;;         You should keep this struct around, and call those previous
;;;;         functions pointers from your own trace callbacks for proper
;;;;         chaining.
;;;; 
;;;;     As an example of how trace hooks are used, have a look at the
;;;;     imgui/sokol_gfx_imgui.h header which implements a realtime
;;;;     debugging UI for sokol_gfx.h on top of Dear ImGui.
;;;; 
;;;; 
;;;;     MEMORY ALLOCATION OVERRIDE
;;;;     ==========================
;;;;     You can override the memory allocation functions at initialization time
;;;;     like this:
;;;; 
;;;;         void* my_alloc(size_t size, void* user_data) {
;;;;             return malloc(size);
;;;;         }
;;;; 
;;;;         void my_free(void* ptr, void* user_data) {
;;;;             free(ptr);
;;;;         }
;;;; 
;;;;         ...
;;;;             sg_setup(&(sg_desc){
;;;;                 // ...
;;;;                 .allocator = {
;;;;                     .alloc_fn = my_alloc,
;;;;                     .free_fn = my_free,
;;;;                     .user_data = ...,
;;;;                 }
;;;;             });
;;;;         ...
;;;; 
;;;;     If no overrides are provided, malloc and free will be used.
;;;; 
;;;;     This only affects memory allocation calls done by sokol_gfx.h
;;;;     itself though, not any allocations in OS libraries.
;;;; 
;;;; 
;;;;     ERROR REPORTING AND LOGGING
;;;;     ===========================
;;;;     To get any logging information at all you need to provide a logging callback in the setup call
;;;;     the easiest way is to use sokol_log.h:
;;;; 
;;;;         #include "sokol_log.h"
;;;; 
;;;;         sg_setup(&(sg_desc){ .logger.func = slog_func });
;;;; 
;;;;     To override logging with your own callback, first write a logging function like this:
;;;; 
;;;;         void my_log(const char* tag,                // e.g. 'sg'
;;;;                     uint32_t log_level,             // 0=panic, 1=error, 2=warn, 3=info
;;;;                     uint32_t log_item_id,           // SG_LOGITEM_*
;;;;                     const char* message_or_null,    // a message string, may be nullptr in release mode
;;;;                     uint32_t line_nr,               // line number in sokol_gfx.h
;;;;                     const char* filename_or_null,   // source filename, may be nullptr in release mode
;;;;                     void* user_data)
;;;;         {
;;;;             ...
;;;;         }
;;;; 
;;;;     ...and then setup sokol-gfx like this:
;;;; 
;;;;         sg_setup(&(sg_desc){
;;;;             .logger = {
;;;;                 .func = my_log,
;;;;                 .user_data = my_user_data,
;;;;             }
;;;;         });
;;;; 
;;;;     The provided logging function must be reentrant (e.g. be callable from
;;;;     different threads).
;;;; 
;;;;     If you don't want to provide your own custom logger it is highly recommended to use
;;;;     the standard logger in sokol_log.h instead, otherwise you won't see any warnings or
;;;;     errors.
;;;; 
;;;; 
;;;;     COMMIT LISTENERS
;;;;     ================
;;;;     It's possible to hook callback functions into sokol-gfx which are called from
;;;;     inside sg_commit() in unspecified order. This is mainly useful for libraries
;;;;     that build on top of sokol_gfx.h to be notified about the end/start of a frame.
;;;; 
;;;;     To add a commit listener, call:
;;;; 
;;;;         static void my_commit_listener(void* user_data) {
;;;;             ...
;;;;         }
;;;; 
;;;;         bool success = sg_add_commit_listener((sg_commit_listener){
;;;;             .func = my_commit_listener,
;;;;             .user_data = ...,
;;;;         });
;;;; 
;;;;     The function returns false if the internal array of commit listeners is full,
;;;;     or the same commit listener had already been added.
;;;; 
;;;;     If the function returns true, my_commit_listener() will be called each frame
;;;;     from inside sg_commit().
;;;; 
;;;;     By default, 1024 distinct commit listeners can be added, but this number
;;;;     can be tweaked in the sg_setup() call:
;;;; 
;;;;         sg_setup(&(sg_desc){
;;;;             .max_commit_listeners = 2048,
;;;;         });
;;;; 
;;;;     An sg_commit_listener item is equal to another if both the function
;;;;     pointer and user_data field are equal.
;;;; 
;;;;     To remove a commit listener:
;;;; 
;;;;         bool success = sg_remove_commit_listener((sg_commit_listener){
;;;;             .func = my_commit_listener,
;;;;             .user_data = ...,
;;;;         });
;;;; 
;;;;     ...where the .func and .user_data field are equal to a previous
;;;;     sg_add_commit_listener() call. The function returns true if the commit
;;;;     listener item was found and removed, and false otherwise.
;;;; 
;;;; 
;;;;     RESOURCE CREATION AND DESTRUCTION IN DETAIL
;;;;     ===========================================
;;;;     The 'vanilla' way to create resource objects is with the 'make functions':
;;;; 
;;;;         sg_buffer sg_make_buffer(const sg_buffer_desc* desc)
;;;;         sg_image sg_make_image(const sg_image_desc* desc)
;;;;         sg_sampler sg_make_sampler(const sg_sampler_desc* desc)
;;;;         sg_shader sg_make_shader(const sg_shader_desc* desc)
;;;;         sg_pipeline sg_make_pipeline(const sg_pipeline_desc* desc)
;;;;         sg_view sg_make_view(const sg_view_desc* desc)
;;;; 
;;;;     This will result in one of three cases:
;;;; 
;;;;         1. The returned handle is invalid. This happens when there are no more
;;;;            free slots in the resource pool for this resource type. An invalid
;;;;            handle is associated with the INVALID resource state, for instance:
;;;; 
;;;;                 sg_buffer buf = sg_make_buffer(...)
;;;;                 if (sg_query_buffer_state(buf) == SG_RESOURCESTATE_INVALID) {
;;;;                     // buffer pool is exhausted
;;;;                 }
;;;; 
;;;;         2. The returned handle is valid, but creating the underlying resource
;;;;            has failed for some reason. This results in a resource object in the
;;;;            FAILED state. The reason *why* resource creation has failed differ
;;;;            by resource type. Look for log messages with more details. A failed
;;;;            resource state can be checked with:
;;;; 
;;;;                 sg_buffer buf = sg_make_buffer(...)
;;;;                 if (sg_query_buffer_state(buf) == SG_RESOURCESTATE_FAILED) {
;;;;                     // creating the resource has failed
;;;;                 }
;;;; 
;;;;         3. And finally, if everything goes right, the returned resource is
;;;;            in resource state VALID and ready to use. This can be checked
;;;;            with:
;;;; 
;;;;                 sg_buffer buf = sg_make_buffer(...)
;;;;                 if (sg_query_buffer_state(buf) == SG_RESOURCESTATE_VALID) {
;;;;                     // creating the resource has failed
;;;;                 }
;;;; 
;;;;     When calling the 'make functions', the created resource goes through a number
;;;;     of states:
;;;; 
;;;;         - INITIAL: the resource slot associated with the new resource is currently
;;;;           free (technically, there is no resource yet, just an empty pool slot)
;;;;         - ALLOC: a handle for the new resource has been allocated, this just means
;;;;           a pool slot has been reserved.
;;;;         - VALID or FAILED: in VALID state any 3D API backend resource objects have
;;;;           been successfully created, otherwise if anything went wrong, the resource
;;;;           will be in FAILED state.
;;;; 
;;;;     Sometimes it makes sense to first grab a handle, but initialize the
;;;;     underlying resource at a later time. For instance when loading data
;;;;     asynchronously from a slow data source, you may know what buffers and
;;;;     textures are needed at an early stage of the loading process, but actually
;;;;     loading the buffer or texture content can only be completed at a later time.
;;;; 
;;;;     For such situations, sokol-gfx resource objects can be created in two steps.
;;;;     You can allocate a handle upfront with one of the 'alloc functions':
;;;; 
;;;;         sg_buffer sg_alloc_buffer(void)
;;;;         sg_image sg_alloc_image(void)
;;;;         sg_sampler sg_alloc_sampler(void)
;;;;         sg_shader sg_alloc_shader(void)
;;;;         sg_pipeline sg_alloc_pipeline(void)
;;;;         sg_view sg_alloc_view(void)
;;;; 
;;;;     This will return a handle with the underlying resource object in the
;;;;     ALLOC state:
;;;; 
;;;;         sg_image img = sg_alloc_image();
;;;;         if (sg_query_image_state(img) == SG_RESOURCESTATE_ALLOC) {
;;;;             // allocating an image handle has succeeded, otherwise
;;;;             // the image pool is full
;;;;         }
;;;; 
;;;;     Such an 'incomplete' handle can be used in most sokol-gfx rendering functions
;;;;     without doing any harm, sokol-gfx will simply skip any rendering operation
;;;;     that involve resources which are not in VALID state.
;;;; 
;;;;     At a later time (for instance once the texture has completed loading
;;;;     asynchronously), the resource creation can be completed by calling one of
;;;;     the 'init functions', those functions take an existing resource handle and
;;;;     'desc struct':
;;;; 
;;;;         void sg_init_buffer(sg_buffer buf, const sg_buffer_desc* desc)
;;;;         void sg_init_image(sg_image img, const sg_image_desc* desc)
;;;;         void sg_init_sampler(sg_sampler smp, const sg_sampler_desc* desc)
;;;;         void sg_init_shader(sg_shader shd, const sg_shader_desc* desc)
;;;;         void sg_init_pipeline(sg_pipeline pip, const sg_pipeline_desc* desc)
;;;;         void sg_init_view(sg_view view, const sg_view_desc* desc)
;;;; 
;;;;     The init functions expect a resource in ALLOC state, and after the function
;;;;     returns, the resource will be either in VALID or FAILED state. Calling
;;;;     an 'alloc function' followed by the matching 'init function' is fully
;;;;     equivalent with calling the 'make function' alone.
;;;; 
;;;;     Destruction can also happen as a two-step process. The 'uninit functions'
;;;;     will put a resource object from the VALID or FAILED state back into the
;;;;     ALLOC state:
;;;; 
;;;;         void sg_uninit_buffer(sg_buffer buf)
;;;;         void sg_uninit_image(sg_image img)
;;;;         void sg_uninit_sampler(sg_sampler smp)
;;;;         void sg_uninit_shader(sg_shader shd)
;;;;         void sg_uninit_pipeline(sg_pipeline pip)
;;;;         void sg_uninit_view(sg_view view)
;;;; 
;;;;     Calling the 'uninit functions' with a resource that is not in the VALID or
;;;;     FAILED state is a no-op.
;;;; 
;;;;     To finally free the pool slot for recycling call the 'dealloc functions':
;;;; 
;;;;         void sg_dealloc_buffer(sg_buffer buf)
;;;;         void sg_dealloc_image(sg_image img)
;;;;         void sg_dealloc_sampler(sg_sampler smp)
;;;;         void sg_dealloc_shader(sg_shader shd)
;;;;         void sg_dealloc_pipeline(sg_pipeline pip)
;;;;         void sg_dealloc_view(sg_view view)
;;;; 
;;;;     Calling the 'dealloc functions' on a resource that's not in ALLOC state is
;;;;     a no-op, but will generate a warning log message.
;;;; 
;;;;     Calling an 'uninit function' and 'dealloc function' in sequence is equivalent
;;;;     with calling the associated 'destroy function':
;;;; 
;;;;         void sg_destroy_buffer(sg_buffer buf)
;;;;         void sg_destroy_image(sg_image img)
;;;;         void sg_destroy_sampler(sg_sampler smp)
;;;;         void sg_destroy_shader(sg_shader shd)
;;;;         void sg_destroy_pipeline(sg_pipeline pip)
;;;;         void sg_destroy_view(sg_view view)
;;;; 
;;;;     The 'destroy functions' can be called on resources in any state and generally
;;;;     do the right thing (for instance if the resource is in ALLOC state, the destroy
;;;;     function will be equivalent to the 'dealloc function' and skip the 'uninit part').
;;;; 
;;;;     And finally to close the circle, the 'fail functions' can be called to manually
;;;;     put a resource in ALLOC state into the FAILED state:
;;;; 
;;;;         sg_fail_buffer(sg_buffer buf)
;;;;         sg_fail_image(sg_image img)
;;;;         sg_fail_sampler(sg_sampler smp)
;;;;         sg_fail_shader(sg_shader shd)
;;;;         sg_fail_pipeline(sg_pipeline pip)
;;;;         sg_fail_view(sg_view view)
;;;; 
;;;;     This is recommended if anything went wrong outside of sokol-gfx during asynchronous
;;;;     resource setup (for instance a file loading operation failed). In this case,
;;;;     the 'fail function' should be called instead of the 'init function'.
;;;; 
;;;;     Calling a 'fail function' on a resource that's not in ALLOC state is a no-op,
;;;;     but will generate a warning log message.
;;;; 
;;;;     NOTE: that two-step resource creation usually only makes sense for buffers,
;;;;     images and views, but not for samplers, shaders or pipelines. Most notably, trying
;;;;     to create a pipeline object with a shader that's not in VALID state will
;;;;     trigger a validation layer error, or if the validation layer is disabled,
;;;;     result in a pipeline object in FAILED state.
;;;; 
;;;; 
;;;;     WEBGPU CAVEATS
;;;;     ==============
;;;;     For a general overview and design notes of the WebGPU backend see:
;;;; 
;;;;         https://floooh.github.io/2023/10/16/sokol-webgpu.html
;;;; 
;;;;     In general, don't expect an automatic speedup when switching from the WebGL2
;;;;     backend to the WebGPU backend. Some WebGPU functions currently actually
;;;;     have a higher CPU overhead than similar WebGL2 functions, leading to the
;;;;     paradoxical situation that some WebGPU code may be slower than similar WebGL2
;;;;     code.
;;;; 
;;;;     - when writing WGSL shader code by hand, a specific bind-slot convention
;;;;       must be used:
;;;; 
;;;;       All uniform block structs must use `@group(0)` and bindings in the
;;;;       range 0..15
;;;; 
;;;;         @group(0) @binding(0..15)
;;;; 
;;;;       All textures, samplers, storage-buffers and storage-images must use `@group(1)`
;;;;       and bindings must be in the range 0..127:
;;;; 
;;;;         @group(1) @binding(0..127)
;;;; 
;;;;       Note that the number of texture, sampler, storage-buffer storage-image bindings
;;;;       is still limited despite the large bind range:
;;;; 
;;;;         - up to 16 textures and sampler across all shader stages
;;;;         - up to 8 storage buffers across all shader stages
;;;;         - up to 4 storage images on the compute shader stage
;;;; 
;;;;       If you use sokol-shdc to generate WGSL shader code, you don't need to worry
;;;;       about the above binding conventions since sokol-shdc will allocate
;;;;       the WGSL bindslots).
;;;; 
;;;;     - The sokol-gfx WebGPU backend uses the sg_desc.uniform_buffer_size item
;;;;       to allocate a single per-frame uniform buffer which must be big enough
;;;;       to hold all data written by sg_apply_uniforms() during a single frame,
;;;;       including a worst-case 256-byte alignment (e.g. each sg_apply_uniform
;;;;       call will cost at least 256 bytes of uniform buffer size). The default size
;;;;       is 4 MB, which is enough for 16384 sg_apply_uniform() calls per
;;;;       frame (assuming the uniform data 'payload' is less than 256 bytes
;;;;       per call). These rules are the same as for the Metal backend, so if
;;;;       you are already using the Metal backend you'll be fine.
;;;; 
;;;;     - sg_apply_bindings(): the sokol-gfx WebGPU backend implements a bindgroup
;;;;       cache to prevent excessive creation and destruction of BindGroup objects
;;;;       when calling sg_apply_bindings(). The number of slots in the bindgroups
;;;;       cache is defined in sg_desc.wgpu.bindgroups_cache_size when calling
;;;;       sg_setup. The cache size must be a power-of-2 number, with the default being
;;;;       1024. The bindgroups cache behaviour can be observed by calling the new
;;;;       function sg_query_stats(), where the following struct items are
;;;;       of interest:
;;;; 
;;;;         .wgpu.num_bindgroup_cache_hits
;;;;         .wgpu.num_bindgroup_cache_misses
;;;;         .wgpu.num_bindgroup_cache_collisions
;;;;         .wgpu_num_bindgroup_cache_invalidates
;;;;         .wgpu.num_bindgroup_cache_vs_hash_key_mismatch
;;;; 
;;;;       The value to pay attention to is `.wgpu.num_bindgroup_cache_collisions`,
;;;;       if this number is consistently higher than a few percent of the
;;;;       .wgpu.num_set_bindgroup value, it might be a good idea to bump the
;;;;       bindgroups cache size to the next power-of-2.
;;;; 
;;;;     - sg_apply_viewport(): WebGPU currently has a unique restriction that viewport
;;;;       rectangles must be contained entirely within the framebuffer. As a shitty
;;;;       workaround sokol_gfx.h will clip incoming viewport rectangles against
;;;;       the framebuffer, but this will distort the clipspace-to-screenspace mapping.
;;;;       There's no proper way to handle this inside sokol_gfx.h, this must be fixed
;;;;       in a future WebGPU update (see: https://github.com/gpuweb/gpuweb/issues/373
;;;;       and https://github.com/gpuweb/gpuweb/pull/5025)
;;;; 
;;;;     - The sokol shader compiler generally adds `diagnostic(off, derivative_uniformity);`
;;;;       into the WGSL output. Currently only the Chrome WebGPU implementation seems
;;;;       to recognize this.
;;;; 
;;;;     - Likewise, the following sokol-gfx pixel formats are not supported in WebGPU:
;;;;       R16, R16SN, RG16, RG16SN, RGBA16, RGBA16SN.
;;;;       Unlike unsupported vertex formats, unsupported pixel formats can be queried
;;;;       in cross-backend code via sg_query_pixelformat() though.
;;;; 
;;;;     - The Emscripten WebGPU shim currently doesn't support the Closure minification
;;;;       post-link-step (e.g. currently the emcc argument '--closure 1' or '--closure 2'
;;;;       will generate broken Javascript code.
;;;; 
;;;;     - sokol-gfx requires the WebGPU device feature `depth32float-stencil8` to be enabled
;;;;       (this should be widely supported)
;;;; 
;;;;     - sokol-gfx expects that the WebGPU device feature `float32-filterable` to *not* be
;;;;       enabled (since this would exclude all iOS devices)
;;;; 
;;;; 
;;;;     LICENSE
;;;;     =======
;;;;     zlib/libpng license
;;;; 
;;;;     Copyright (c) 2018 Andre Weissflog
;;;; 
;;;;     This software is provided 'as-is', without any express or implied warranty.
;;;;     In no event will the authors be held liable for any damages arising from the
;;;;     use of this software.
;;;; 
;;;;     Permission is granted to anyone to use this software for any purpose,
;;;;     including commercial applications, and to alter it and redistribute it
;;;;     freely, subject to the following restrictions:
;;;; 
;;;;         1. The origin of this software must not be misrepresented; you must not
;;;;         claim that you wrote the original software. If you use this software in a
;;;;         product, an acknowledgment in the product documentation would be
;;;;         appreciated but is not required.
;;;; 
;;;;         2. Altered source versions must be plainly marked as such, and must not
;;;;         be misrepresented as being the original software.
;;;; 
;;;;         3. This notice may not be removed or altered from any source
;;;;         distribution.

;; Enums and Constants

;; Constants
(cl:defconstant +SG-INVALID-ID+ 0)
(cl:defconstant +SG-NUM-INFLIGHT-FRAMES+ 2)
(cl:defconstant +SG-MAX-COLOR-ATTACHMENTS+ 8)
(cl:defconstant +SG-MAX-UNIFORMBLOCK-MEMBERS+ 16)
(cl:defconstant +SG-MAX-VERTEX-ATTRIBUTES+ 16)
(cl:defconstant +SG-MAX-MIPMAPS+ 16)
(cl:defconstant +SG-MAX-VERTEXBUFFER-BINDSLOTS+ 8)
(cl:defconstant +SG-MAX-UNIFORMBLOCK-BINDSLOTS+ 8)
(cl:defconstant +SG-MAX-VIEW-BINDSLOTS+ 32)
(cl:defconstant +SG-MAX-SAMPLER-BINDSLOTS+ 12)
(cl:defconstant +SG-MAX-TEXTURE-SAMPLER-PAIRS+ 32)
(cl:defconstant +SG-MAX-PORTABLE-COLOR-ATTACHMENTS+ 4)
(cl:defconstant +SG-MAX-PORTABLE-TEXTURE-BINDINGS-PER-STAGE+ 16)
(cl:defconstant +SG-MAX-PORTABLE-STORAGEBUFFER-BINDINGS-PER-STAGE+ 8)
(cl:defconstant +SG-MAX-PORTABLE-STORAGEIMAGE-BINDINGS-PER-STAGE+ 4)

(cffi:defcenum sg-backend
  :SG-BACKEND-GLCORE
  :SG-BACKEND-GLES3
  :SG-BACKEND-D3D11
  :SG-BACKEND-METAL-IOS
  :SG-BACKEND-METAL-MACOS
  :SG-BACKEND-METAL-SIMULATOR
  :SG-BACKEND-WGPU
  :SG-BACKEND-VULKAN
  :SG-BACKEND-DUMMY
)

(cffi:defcenum sg-pixel-format
  :-SG-PIXELFORMAT-DEFAULT
  :SG-PIXELFORMAT-NONE
  :SG-PIXELFORMAT-R8
  :SG-PIXELFORMAT-R8SN
  :SG-PIXELFORMAT-R8UI
  :SG-PIXELFORMAT-R8SI
  :SG-PIXELFORMAT-R16
  :SG-PIXELFORMAT-R16SN
  :SG-PIXELFORMAT-R16UI
  :SG-PIXELFORMAT-R16SI
  :SG-PIXELFORMAT-R16F
  :SG-PIXELFORMAT-RG8
  :SG-PIXELFORMAT-RG8SN
  :SG-PIXELFORMAT-RG8UI
  :SG-PIXELFORMAT-RG8SI
  :SG-PIXELFORMAT-R32UI
  :SG-PIXELFORMAT-R32SI
  :SG-PIXELFORMAT-R32F
  :SG-PIXELFORMAT-RG16
  :SG-PIXELFORMAT-RG16SN
  :SG-PIXELFORMAT-RG16UI
  :SG-PIXELFORMAT-RG16SI
  :SG-PIXELFORMAT-RG16F
  :SG-PIXELFORMAT-RGBA8
  :SG-PIXELFORMAT-SRGB8A8
  :SG-PIXELFORMAT-RGBA8SN
  :SG-PIXELFORMAT-RGBA8UI
  :SG-PIXELFORMAT-RGBA8SI
  :SG-PIXELFORMAT-BGRA8
  :SG-PIXELFORMAT-RGB10A2
  :SG-PIXELFORMAT-RG11B10F
  :SG-PIXELFORMAT-RGB9E5
  :SG-PIXELFORMAT-RG32UI
  :SG-PIXELFORMAT-RG32SI
  :SG-PIXELFORMAT-RG32F
  :SG-PIXELFORMAT-RGBA16
  :SG-PIXELFORMAT-RGBA16SN
  :SG-PIXELFORMAT-RGBA16UI
  :SG-PIXELFORMAT-RGBA16SI
  :SG-PIXELFORMAT-RGBA16F
  :SG-PIXELFORMAT-RGBA32UI
  :SG-PIXELFORMAT-RGBA32SI
  :SG-PIXELFORMAT-RGBA32F
  :SG-PIXELFORMAT-DEPTH
  :SG-PIXELFORMAT-DEPTH-STENCIL
  :SG-PIXELFORMAT-BC1-RGBA
  :SG-PIXELFORMAT-BC2-RGBA
  :SG-PIXELFORMAT-BC3-RGBA
  :SG-PIXELFORMAT-BC3-SRGBA
  :SG-PIXELFORMAT-BC4-R
  :SG-PIXELFORMAT-BC4-RSN
  :SG-PIXELFORMAT-BC5-RG
  :SG-PIXELFORMAT-BC5-RGSN
  :SG-PIXELFORMAT-BC6H-RGBF
  :SG-PIXELFORMAT-BC6H-RGBUF
  :SG-PIXELFORMAT-BC7-RGBA
  :SG-PIXELFORMAT-BC7-SRGBA
  :SG-PIXELFORMAT-ETC2-RGB8
  :SG-PIXELFORMAT-ETC2-SRGB8
  :SG-PIXELFORMAT-ETC2-RGB8A1
  :SG-PIXELFORMAT-ETC2-RGBA8
  :SG-PIXELFORMAT-ETC2-SRGB8A8
  :SG-PIXELFORMAT-EAC-R11
  :SG-PIXELFORMAT-EAC-R11SN
  :SG-PIXELFORMAT-EAC-RG11
  :SG-PIXELFORMAT-EAC-RG11SN
  :SG-PIXELFORMAT-ASTC-4x4-RGBA
  :SG-PIXELFORMAT-ASTC-4x4-SRGBA
  :-SG-PIXELFORMAT-NUM
  (:-SG-PIXELFORMAT-FORCE-U32 2147483647)
)

(cffi:defcenum sg-resource-state
  :SG-RESOURCESTATE-INITIAL
  :SG-RESOURCESTATE-ALLOC
  :SG-RESOURCESTATE-VALID
  :SG-RESOURCESTATE-FAILED
  :SG-RESOURCESTATE-INVALID
  (:-SG-RESOURCESTATE-FORCE-U32 2147483647)
)

(cffi:defcenum sg-index-type
  :-SG-INDEXTYPE-DEFAULT
  :SG-INDEXTYPE-NONE
  :SG-INDEXTYPE-UINT16
  :SG-INDEXTYPE-UINT32
  :-SG-INDEXTYPE-NUM
  (:-SG-INDEXTYPE-FORCE-U32 2147483647)
)

(cffi:defcenum sg-image-type
  :-SG-IMAGETYPE-DEFAULT
  :SG-IMAGETYPE-2D
  :SG-IMAGETYPE-CUBE
  :SG-IMAGETYPE-3D
  :SG-IMAGETYPE-ARRAY
  :-SG-IMAGETYPE-NUM
  (:-SG-IMAGETYPE-FORCE-U32 2147483647)
)

(cffi:defcenum sg-image-sample-type
  :-SG-IMAGESAMPLETYPE-DEFAULT
  :SG-IMAGESAMPLETYPE-FLOAT
  :SG-IMAGESAMPLETYPE-DEPTH
  :SG-IMAGESAMPLETYPE-SINT
  :SG-IMAGESAMPLETYPE-UINT
  :SG-IMAGESAMPLETYPE-UNFILTERABLE-FLOAT
  :-SG-IMAGESAMPLETYPE-NUM
  (:-SG-IMAGESAMPLETYPE-FORCE-U32 2147483647)
)

(cffi:defcenum sg-sampler-type
  :-SG-SAMPLERTYPE-DEFAULT
  :SG-SAMPLERTYPE-FILTERING
  :SG-SAMPLERTYPE-NONFILTERING
  :SG-SAMPLERTYPE-COMPARISON
  :-SG-SAMPLERTYPE-NUM
  :-SG-SAMPLERTYPE-FORCE-U32
)

(cffi:defcenum sg-primitive-type
  :-SG-PRIMITIVETYPE-DEFAULT
  :SG-PRIMITIVETYPE-POINTS
  :SG-PRIMITIVETYPE-LINES
  :SG-PRIMITIVETYPE-LINE-STRIP
  :SG-PRIMITIVETYPE-TRIANGLES
  :SG-PRIMITIVETYPE-TRIANGLE-STRIP
  :-SG-PRIMITIVETYPE-NUM
  (:-SG-PRIMITIVETYPE-FORCE-U32 2147483647)
)

(cffi:defcenum sg-filter
  :-SG-FILTER-DEFAULT
  :SG-FILTER-NEAREST
  :SG-FILTER-LINEAR
  :-SG-FILTER-NUM
  (:-SG-FILTER-FORCE-U32 2147483647)
)

(cffi:defcenum sg-wrap
  :-SG-WRAP-DEFAULT
  :SG-WRAP-REPEAT
  :SG-WRAP-CLAMP-TO-EDGE
  :SG-WRAP-CLAMP-TO-BORDER
  :SG-WRAP-MIRRORED-REPEAT
  :-SG-WRAP-NUM
  (:-SG-WRAP-FORCE-U32 2147483647)
)

(cffi:defcenum sg-border-color
  :-SG-BORDERCOLOR-DEFAULT
  :SG-BORDERCOLOR-TRANSPARENT-BLACK
  :SG-BORDERCOLOR-OPAQUE-BLACK
  :SG-BORDERCOLOR-OPAQUE-WHITE
  :-SG-BORDERCOLOR-NUM
  (:-SG-BORDERCOLOR-FORCE-U32 2147483647)
)

(cffi:defcenum sg-vertex-format
  :SG-VERTEXFORMAT-INVALID
  :SG-VERTEXFORMAT-FLOAT
  :SG-VERTEXFORMAT-FLOAT2
  :SG-VERTEXFORMAT-FLOAT3
  :SG-VERTEXFORMAT-FLOAT4
  :SG-VERTEXFORMAT-INT
  :SG-VERTEXFORMAT-INT2
  :SG-VERTEXFORMAT-INT3
  :SG-VERTEXFORMAT-INT4
  :SG-VERTEXFORMAT-UINT
  :SG-VERTEXFORMAT-UINT2
  :SG-VERTEXFORMAT-UINT3
  :SG-VERTEXFORMAT-UINT4
  :SG-VERTEXFORMAT-BYTE4
  :SG-VERTEXFORMAT-BYTE4N
  :SG-VERTEXFORMAT-UBYTE4
  :SG-VERTEXFORMAT-UBYTE4N
  :SG-VERTEXFORMAT-SHORT2
  :SG-VERTEXFORMAT-SHORT2N
  :SG-VERTEXFORMAT-USHORT2
  :SG-VERTEXFORMAT-USHORT2N
  :SG-VERTEXFORMAT-SHORT4
  :SG-VERTEXFORMAT-SHORT4N
  :SG-VERTEXFORMAT-USHORT4
  :SG-VERTEXFORMAT-USHORT4N
  :SG-VERTEXFORMAT-UINT10-N2
  :SG-VERTEXFORMAT-HALF2
  :SG-VERTEXFORMAT-HALF4
  :-SG-VERTEXFORMAT-NUM
  (:-SG-VERTEXFORMAT-FORCE-U32 2147483647)
)

(cffi:defcenum sg-vertex-step
  :-SG-VERTEXSTEP-DEFAULT
  :SG-VERTEXSTEP-PER-VERTEX
  :SG-VERTEXSTEP-PER-INSTANCE
  :-SG-VERTEXSTEP-NUM
  (:-SG-VERTEXSTEP-FORCE-U32 2147483647)
)

(cffi:defcenum sg-uniform-type
  :SG-UNIFORMTYPE-INVALID
  :SG-UNIFORMTYPE-FLOAT
  :SG-UNIFORMTYPE-FLOAT2
  :SG-UNIFORMTYPE-FLOAT3
  :SG-UNIFORMTYPE-FLOAT4
  :SG-UNIFORMTYPE-INT
  :SG-UNIFORMTYPE-INT2
  :SG-UNIFORMTYPE-INT3
  :SG-UNIFORMTYPE-INT4
  :SG-UNIFORMTYPE-MAT4
  :-SG-UNIFORMTYPE-NUM
  (:-SG-UNIFORMTYPE-FORCE-U32 2147483647)
)

(cffi:defcenum sg-uniform-layout
  :-SG-UNIFORMLAYOUT-DEFAULT
  :SG-UNIFORMLAYOUT-NATIVE
  :SG-UNIFORMLAYOUT-STD140
  :-SG-UNIFORMLAYOUT-NUM
  (:-SG-UNIFORMLAYOUT-FORCE-U32 2147483647)
)

(cffi:defcenum sg-cull-mode
  :-SG-CULLMODE-DEFAULT
  :SG-CULLMODE-NONE
  :SG-CULLMODE-FRONT
  :SG-CULLMODE-BACK
  :-SG-CULLMODE-NUM
  (:-SG-CULLMODE-FORCE-U32 2147483647)
)

(cffi:defcenum sg-face-winding
  :-SG-FACEWINDING-DEFAULT
  :SG-FACEWINDING-CCW
  :SG-FACEWINDING-CW
  :-SG-FACEWINDING-NUM
  (:-SG-FACEWINDING-FORCE-U32 2147483647)
)

(cffi:defcenum sg-compare-func
  :-SG-COMPAREFUNC-DEFAULT
  :SG-COMPAREFUNC-NEVER
  :SG-COMPAREFUNC-LESS
  :SG-COMPAREFUNC-EQUAL
  :SG-COMPAREFUNC-LESS-EQUAL
  :SG-COMPAREFUNC-GREATER
  :SG-COMPAREFUNC-NOT-EQUAL
  :SG-COMPAREFUNC-GREATER-EQUAL
  :SG-COMPAREFUNC-ALWAYS
  :-SG-COMPAREFUNC-NUM
  (:-SG-COMPAREFUNC-FORCE-U32 2147483647)
)

(cffi:defcenum sg-stencil-op
  :-SG-STENCILOP-DEFAULT
  :SG-STENCILOP-KEEP
  :SG-STENCILOP-ZERO
  :SG-STENCILOP-REPLACE
  :SG-STENCILOP-INCR-CLAMP
  :SG-STENCILOP-DECR-CLAMP
  :SG-STENCILOP-INVERT
  :SG-STENCILOP-INCR-WRAP
  :SG-STENCILOP-DECR-WRAP
  :-SG-STENCILOP-NUM
  (:-SG-STENCILOP-FORCE-U32 2147483647)
)

(cffi:defcenum sg-blend-factor
  :-SG-BLENDFACTOR-DEFAULT
  :SG-BLENDFACTOR-ZERO
  :SG-BLENDFACTOR-ONE
  :SG-BLENDFACTOR-SRC-COLOR
  :SG-BLENDFACTOR-ONE-MINUS-SRC-COLOR
  :SG-BLENDFACTOR-SRC-ALPHA
  :SG-BLENDFACTOR-ONE-MINUS-SRC-ALPHA
  :SG-BLENDFACTOR-DST-COLOR
  :SG-BLENDFACTOR-ONE-MINUS-DST-COLOR
  :SG-BLENDFACTOR-DST-ALPHA
  :SG-BLENDFACTOR-ONE-MINUS-DST-ALPHA
  :SG-BLENDFACTOR-SRC-ALPHA-SATURATED
  :SG-BLENDFACTOR-BLEND-COLOR
  :SG-BLENDFACTOR-ONE-MINUS-BLEND-COLOR
  :SG-BLENDFACTOR-BLEND-ALPHA
  :SG-BLENDFACTOR-ONE-MINUS-BLEND-ALPHA
  :-SG-BLENDFACTOR-NUM
  (:-SG-BLENDFACTOR-FORCE-U32 2147483647)
)

(cffi:defcenum sg-blend-op
  :-SG-BLENDOP-DEFAULT
  :SG-BLENDOP-ADD
  :SG-BLENDOP-SUBTRACT
  :SG-BLENDOP-REVERSE-SUBTRACT
  :SG-BLENDOP-MIN
  :SG-BLENDOP-MAX
  :-SG-BLENDOP-NUM
  (:-SG-BLENDOP-FORCE-U32 2147483647)
)

(cffi:defcenum sg-color-mask
  (:-SG-COLORMASK-DEFAULT 0)
  (:SG-COLORMASK-NONE 16)
  (:SG-COLORMASK-R 1)
  (:SG-COLORMASK-G 2)
  (:SG-COLORMASK-RG 3)
  (:SG-COLORMASK-B 4)
  (:SG-COLORMASK-RB 5)
  (:SG-COLORMASK-GB 6)
  (:SG-COLORMASK-RGB 7)
  (:SG-COLORMASK-A 8)
  (:SG-COLORMASK-RA 9)
  (:SG-COLORMASK-GA 10)
  (:SG-COLORMASK-RGA 11)
  (:SG-COLORMASK-BA 12)
  (:SG-COLORMASK-RBA 13)
  (:SG-COLORMASK-GBA 14)
  (:SG-COLORMASK-RGBA 15)
  (:-SG-COLORMASK-FORCE-U32 2147483647)
)

(cffi:defcenum sg-load-action
  :-SG-LOADACTION-DEFAULT
  :SG-LOADACTION-CLEAR
  :SG-LOADACTION-LOAD
  :SG-LOADACTION-DONTCARE
  (:-SG-LOADACTION-FORCE-U32 2147483647)
)

(cffi:defcenum sg-store-action
  :-SG-STOREACTION-DEFAULT
  :SG-STOREACTION-STORE
  :SG-STOREACTION-DONTCARE
  (:-SG-STOREACTION-FORCE-U32 2147483647)
)

(cffi:defcenum sg-view-type
  :SG-VIEWTYPE-INVALID
  :SG-VIEWTYPE-STORAGEBUFFER
  :SG-VIEWTYPE-STORAGEIMAGE
  :SG-VIEWTYPE-TEXTURE
  :SG-VIEWTYPE-COLORATTACHMENT
  :SG-VIEWTYPE-RESOLVEATTACHMENT
  :SG-VIEWTYPE-DEPTHSTENCILATTACHMENT
  (:-SG-VIEWTYPE-FORCE-U32 2147483647)
)

(cffi:defcenum sg-shader-stage
  :SG-SHADERSTAGE-NONE
  :SG-SHADERSTAGE-VERTEX
  :SG-SHADERSTAGE-FRAGMENT
  :SG-SHADERSTAGE-COMPUTE
  (:-SG-SHADERSTAGE-FORCE-U32 2147483647)
)

(cffi:defcenum sg-shader-attr-base-type
  :SG-SHADERATTRBASETYPE-UNDEFINED
  :SG-SHADERATTRBASETYPE-FLOAT
  :SG-SHADERATTRBASETYPE-SINT
  :SG-SHADERATTRBASETYPE-UINT
  (:-SG-SHADERATTRBASETYPE-FORCE-U32 2147483647)
)

(cffi:defcenum sg-log-item
  :SG-LOGITEM-OK
  :SG-LOGITEM-MALLOC-FAILED
  :SG-LOGITEM-GL-TEXTURE-FORMAT-NOT-SUPPORTED
  :SG-LOGITEM-GL-3D-TEXTURES-NOT-SUPPORTED
  :SG-LOGITEM-GL-ARRAY-TEXTURES-NOT-SUPPORTED
  :SG-LOGITEM-GL-STORAGEBUFFER-GLSL-BINDING-OUT-OF-RANGE
  :SG-LOGITEM-GL-STORAGEIMAGE-GLSL-BINDING-OUT-OF-RANGE
  :SG-LOGITEM-GL-SHADER-COMPILATION-FAILED
  :SG-LOGITEM-GL-SHADER-LINKING-FAILED
  :SG-LOGITEM-GL-VERTEX-ATTRIBUTE-NOT-FOUND-IN-SHADER
  :SG-LOGITEM-GL-UNIFORMBLOCK-NAME-NOT-FOUND-IN-SHADER
  :SG-LOGITEM-GL-IMAGE-SAMPLER-NAME-NOT-FOUND-IN-SHADER
  :SG-LOGITEM-GL-FRAMEBUFFER-STATUS-UNDEFINED
  :SG-LOGITEM-GL-FRAMEBUFFER-STATUS-INCOMPLETE-ATTACHMENT
  :SG-LOGITEM-GL-FRAMEBUFFER-STATUS-INCOMPLETE-MISSING-ATTACHMENT
  :SG-LOGITEM-GL-FRAMEBUFFER-STATUS-UNSUPPORTED
  :SG-LOGITEM-GL-FRAMEBUFFER-STATUS-INCOMPLETE-MULTISAMPLE
  :SG-LOGITEM-GL-FRAMEBUFFER-STATUS-UNKNOWN
  :SG-LOGITEM-D3D11-FEATURE-LEVEL-0-DETECTED
  :SG-LOGITEM-D3D11-CREATE-BUFFER-FAILED
  :SG-LOGITEM-D3D11-CREATE-BUFFER-SRV-FAILED
  :SG-LOGITEM-D3D11-CREATE-BUFFER-UAV-FAILED
  :SG-LOGITEM-D3D11-CREATE-DEPTH-TEXTURE-UNSUPPORTED-PIXEL-FORMAT
  :SG-LOGITEM-D3D11-CREATE-DEPTH-TEXTURE-FAILED
  :SG-LOGITEM-D3D11-CREATE-2D-TEXTURE-UNSUPPORTED-PIXEL-FORMAT
  :SG-LOGITEM-D3D11-CREATE-2D-TEXTURE-FAILED
  :SG-LOGITEM-D3D11-CREATE-2D-SRV-FAILED
  :SG-LOGITEM-D3D11-CREATE-3D-TEXTURE-UNSUPPORTED-PIXEL-FORMAT
  :SG-LOGITEM-D3D11-CREATE-3D-TEXTURE-FAILED
  :SG-LOGITEM-D3D11-CREATE-3D-SRV-FAILED
  :SG-LOGITEM-D3D11-CREATE-MSAA-TEXTURE-FAILED
  :SG-LOGITEM-D3D11-CREATE-SAMPLER-STATE-FAILED
  :SG-LOGITEM-D3D11-UNIFORMBLOCK-HLSL-REGISTER-B-OUT-OF-RANGE
  :SG-LOGITEM-D3D11-STORAGEBUFFER-HLSL-REGISTER-T-OUT-OF-RANGE
  :SG-LOGITEM-D3D11-STORAGEBUFFER-HLSL-REGISTER-U-OUT-OF-RANGE
  :SG-LOGITEM-D3D11-IMAGE-HLSL-REGISTER-T-OUT-OF-RANGE
  :SG-LOGITEM-D3D11-STORAGEIMAGE-HLSL-REGISTER-U-OUT-OF-RANGE
  :SG-LOGITEM-D3D11-SAMPLER-HLSL-REGISTER-S-OUT-OF-RANGE
  :SG-LOGITEM-D3D11-LOAD-D3DCOMPILER-47-DLL-FAILED
  :SG-LOGITEM-D3D11-SHADER-COMPILATION-FAILED
  :SG-LOGITEM-D3D11-SHADER-COMPILATION-OUTPUT
  :SG-LOGITEM-D3D11-CREATE-CONSTANT-BUFFER-FAILED
  :SG-LOGITEM-D3D11-CREATE-INPUT-LAYOUT-FAILED
  :SG-LOGITEM-D3D11-CREATE-RASTERIZER-STATE-FAILED
  :SG-LOGITEM-D3D11-CREATE-DEPTH-STENCIL-STATE-FAILED
  :SG-LOGITEM-D3D11-CREATE-BLEND-STATE-FAILED
  :SG-LOGITEM-D3D11-CREATE-RTV-FAILED
  :SG-LOGITEM-D3D11-CREATE-DSV-FAILED
  :SG-LOGITEM-D3D11-CREATE-UAV-FAILED
  :SG-LOGITEM-D3D11-MAP-FOR-UPDATE-BUFFER-FAILED
  :SG-LOGITEM-D3D11-MAP-FOR-APPEND-BUFFER-FAILED
  :SG-LOGITEM-D3D11-MAP-FOR-UPDATE-IMAGE-FAILED
  :SG-LOGITEM-METAL-CREATE-BUFFER-FAILED
  :SG-LOGITEM-METAL-TEXTURE-FORMAT-NOT-SUPPORTED
  :SG-LOGITEM-METAL-CREATE-TEXTURE-FAILED
  :SG-LOGITEM-METAL-CREATE-SAMPLER-FAILED
  :SG-LOGITEM-METAL-SHADER-COMPILATION-FAILED
  :SG-LOGITEM-METAL-SHADER-CREATION-FAILED
  :SG-LOGITEM-METAL-SHADER-COMPILATION-OUTPUT
  :SG-LOGITEM-METAL-SHADER-ENTRY-NOT-FOUND
  :SG-LOGITEM-METAL-UNIFORMBLOCK-MSL-BUFFER-SLOT-OUT-OF-RANGE
  :SG-LOGITEM-METAL-STORAGEBUFFER-MSL-BUFFER-SLOT-OUT-OF-RANGE
  :SG-LOGITEM-METAL-STORAGEIMAGE-MSL-TEXTURE-SLOT-OUT-OF-RANGE
  :SG-LOGITEM-METAL-IMAGE-MSL-TEXTURE-SLOT-OUT-OF-RANGE
  :SG-LOGITEM-METAL-SAMPLER-MSL-SAMPLER-SLOT-OUT-OF-RANGE
  :SG-LOGITEM-METAL-CREATE-CPS-FAILED
  :SG-LOGITEM-METAL-CREATE-CPS-OUTPUT
  :SG-LOGITEM-METAL-CREATE-RPS-FAILED
  :SG-LOGITEM-METAL-CREATE-RPS-OUTPUT
  :SG-LOGITEM-METAL-CREATE-DSS-FAILED
  :SG-LOGITEM-WGPU-BINDGROUPS-POOL-EXHAUSTED
  :SG-LOGITEM-WGPU-BINDGROUPSCACHE-SIZE-GREATER-ONE
  :SG-LOGITEM-WGPU-BINDGROUPSCACHE-SIZE-POW2
  :SG-LOGITEM-WGPU-CREATEBINDGROUP-FAILED
  :SG-LOGITEM-WGPU-CREATE-BUFFER-FAILED
  :SG-LOGITEM-WGPU-CREATE-TEXTURE-FAILED
  :SG-LOGITEM-WGPU-CREATE-TEXTURE-VIEW-FAILED
  :SG-LOGITEM-WGPU-CREATE-SAMPLER-FAILED
  :SG-LOGITEM-WGPU-CREATE-SHADER-MODULE-FAILED
  :SG-LOGITEM-WGPU-SHADER-CREATE-BINDGROUP-LAYOUT-FAILED
  :SG-LOGITEM-WGPU-UNIFORMBLOCK-WGSL-GROUP0-BINDING-OUT-OF-RANGE
  :SG-LOGITEM-WGPU-TEXTURE-WGSL-GROUP1-BINDING-OUT-OF-RANGE
  :SG-LOGITEM-WGPU-STORAGEBUFFER-WGSL-GROUP1-BINDING-OUT-OF-RANGE
  :SG-LOGITEM-WGPU-STORAGEIMAGE-WGSL-GROUP1-BINDING-OUT-OF-RANGE
  :SG-LOGITEM-WGPU-SAMPLER-WGSL-GROUP1-BINDING-OUT-OF-RANGE
  :SG-LOGITEM-WGPU-CREATE-PIPELINE-LAYOUT-FAILED
  :SG-LOGITEM-WGPU-CREATE-RENDER-PIPELINE-FAILED
  :SG-LOGITEM-WGPU-CREATE-COMPUTE-PIPELINE-FAILED
  :SG-LOGITEM-VULKAN-REQUIRED-EXTENSION-FUNCTION-MISSING
  :SG-LOGITEM-VULKAN-ALLOC-DEVICE-MEMORY-NO-SUITABLE-MEMORY-TYPE
  :SG-LOGITEM-VULKAN-ALLOCATE-MEMORY-FAILED
  :SG-LOGITEM-VULKAN-ALLOC-BUFFER-DEVICE-MEMORY-FAILED
  :SG-LOGITEM-VULKAN-ALLOC-IMAGE-DEVICE-MEMORY-FAILED
  :SG-LOGITEM-VULKAN-DELETE-QUEUE-EXHAUSTED
  :SG-LOGITEM-VULKAN-STAGING-CREATE-BUFFER-FAILED
  :SG-LOGITEM-VULKAN-STAGING-ALLOCATE-MEMORY-FAILED
  :SG-LOGITEM-VULKAN-STAGING-BIND-BUFFER-MEMORY-FAILED
  :SG-LOGITEM-VULKAN-STAGING-STREAM-BUFFER-OVERFLOW
  :SG-LOGITEM-VULKAN-CREATE-SHARED-BUFFER-FAILED
  :SG-LOGITEM-VULKAN-ALLOCATE-SHARED-BUFFER-MEMORY-FAILED
  :SG-LOGITEM-VULKAN-BIND-SHARED-BUFFER-MEMORY-FAILED
  :SG-LOGITEM-VULKAN-MAP-SHARED-BUFFER-MEMORY-FAILED
  :SG-LOGITEM-VULKAN-CREATE-BUFFER-FAILED
  :SG-LOGITEM-VULKAN-BIND-BUFFER-MEMORY-FAILED
  :SG-LOGITEM-VULKAN-CREATE-IMAGE-FAILED
  :SG-LOGITEM-VULKAN-BIND-IMAGE-MEMORY-FAILED
  :SG-LOGITEM-VULKAN-CREATE-SHADER-MODULE-FAILED
  :SG-LOGITEM-VULKAN-UNIFORMBLOCK-SPIRV-SET0-BINDING-OUT-OF-RANGE
  :SG-LOGITEM-VULKAN-TEXTURE-SPIRV-SET1-BINDING-OUT-OF-RANGE
  :SG-LOGITEM-VULKAN-STORAGEBUFFER-SPIRV-SET1-BINDING-OUT-OF-RANGE
  :SG-LOGITEM-VULKAN-STORAGEIMAGE-SPIRV-SET1-BINDING-OUT-OF-RANGE
  :SG-LOGITEM-VULKAN-SAMPLER-SPIRV-SET1-BINDING-OUT-OF-RANGE
  :SG-LOGITEM-VULKAN-CREATE-DESCRIPTOR-SET-LAYOUT-FAILED
  :SG-LOGITEM-VULKAN-CREATE-PIPELINE-LAYOUT-FAILED
  :SG-LOGITEM-VULKAN-CREATE-GRAPHICS-PIPELINE-FAILED
  :SG-LOGITEM-VULKAN-CREATE-COMPUTE-PIPELINE-FAILED
  :SG-LOGITEM-VULKAN-CREATE-IMAGE-VIEW-FAILED
  :SG-LOGITEM-VULKAN-VIEW-MAX-DESCRIPTOR-SIZE
  :SG-LOGITEM-VULKAN-CREATE-SAMPLER-FAILED
  :SG-LOGITEM-VULKAN-SAMPLER-MAX-DESCRIPTOR-SIZE
  :SG-LOGITEM-VULKAN-WAIT-FOR-FENCE-FAILED
  :SG-LOGITEM-VULKAN-UNIFORM-BUFFER-OVERFLOW
  :SG-LOGITEM-VULKAN-DESCRIPTOR-BUFFER-OVERFLOW
  :SG-LOGITEM-IDENTICAL-COMMIT-LISTENER
  :SG-LOGITEM-COMMIT-LISTENER-ARRAY-FULL
  :SG-LOGITEM-TRACE-HOOKS-NOT-ENABLED
  :SG-LOGITEM-DEALLOC-BUFFER-INVALID-STATE
  :SG-LOGITEM-DEALLOC-IMAGE-INVALID-STATE
  :SG-LOGITEM-DEALLOC-SAMPLER-INVALID-STATE
  :SG-LOGITEM-DEALLOC-SHADER-INVALID-STATE
  :SG-LOGITEM-DEALLOC-PIPELINE-INVALID-STATE
  :SG-LOGITEM-DEALLOC-VIEW-INVALID-STATE
  :SG-LOGITEM-INIT-BUFFER-INVALID-STATE
  :SG-LOGITEM-INIT-IMAGE-INVALID-STATE
  :SG-LOGITEM-INIT-SAMPLER-INVALID-STATE
  :SG-LOGITEM-INIT-SHADER-INVALID-STATE
  :SG-LOGITEM-INIT-PIPELINE-INVALID-STATE
  :SG-LOGITEM-INIT-VIEW-INVALID-STATE
  :SG-LOGITEM-UNINIT-BUFFER-INVALID-STATE
  :SG-LOGITEM-UNINIT-IMAGE-INVALID-STATE
  :SG-LOGITEM-UNINIT-SAMPLER-INVALID-STATE
  :SG-LOGITEM-UNINIT-SHADER-INVALID-STATE
  :SG-LOGITEM-UNINIT-PIPELINE-INVALID-STATE
  :SG-LOGITEM-UNINIT-VIEW-INVALID-STATE
  :SG-LOGITEM-FAIL-BUFFER-INVALID-STATE
  :SG-LOGITEM-FAIL-IMAGE-INVALID-STATE
  :SG-LOGITEM-FAIL-SAMPLER-INVALID-STATE
  :SG-LOGITEM-FAIL-SHADER-INVALID-STATE
  :SG-LOGITEM-FAIL-PIPELINE-INVALID-STATE
  :SG-LOGITEM-FAIL-VIEW-INVALID-STATE
  :SG-LOGITEM-BUFFER-POOL-EXHAUSTED
  :SG-LOGITEM-IMAGE-POOL-EXHAUSTED
  :SG-LOGITEM-SAMPLER-POOL-EXHAUSTED
  :SG-LOGITEM-SHADER-POOL-EXHAUSTED
  :SG-LOGITEM-PIPELINE-POOL-EXHAUSTED
  :SG-LOGITEM-VIEW-POOL-EXHAUSTED
  :SG-LOGITEM-BEGINPASS-TOO-MANY-COLOR-ATTACHMENTS
  :SG-LOGITEM-BEGINPASS-TOO-MANY-RESOLVE-ATTACHMENTS
  :SG-LOGITEM-BEGINPASS-ATTACHMENTS-ALIVE
  :SG-LOGITEM-DRAW-WITHOUT-BINDINGS
  :SG-LOGITEM-SHADERDESC-TOO-MANY-VERTEXSTAGE-TEXTURES
  :SG-LOGITEM-SHADERDESC-TOO-MANY-FRAGMENTSTAGE-TEXTURES
  :SG-LOGITEM-SHADERDESC-TOO-MANY-COMPUTESTAGE-TEXTURES
  :SG-LOGITEM-SHADERDESC-TOO-MANY-VERTEXSTAGE-STORAGEBUFFERS
  :SG-LOGITEM-SHADERDESC-TOO-MANY-FRAGMENTSTAGE-STORAGEBUFFERS
  :SG-LOGITEM-SHADERDESC-TOO-MANY-COMPUTESTAGE-STORAGEBUFFERS
  :SG-LOGITEM-SHADERDESC-TOO-MANY-VERTEXSTAGE-STORAGEIMAGES
  :SG-LOGITEM-SHADERDESC-TOO-MANY-FRAGMENTSTAGE-STORAGEIMAGES
  :SG-LOGITEM-SHADERDESC-TOO-MANY-COMPUTESTAGE-STORAGEIMAGES
  :SG-LOGITEM-SHADERDESC-TOO-MANY-VERTEXSTAGE-TEXTURESAMPLERPAIRS
  :SG-LOGITEM-SHADERDESC-TOO-MANY-FRAGMENTSTAGE-TEXTURESAMPLERPAIRS
  :SG-LOGITEM-SHADERDESC-TOO-MANY-COMPUTESTAGE-TEXTURESAMPLERPAIRS
  :SG-LOGITEM-VALIDATE-BUFFERDESC-CANARY
  :SG-LOGITEM-VALIDATE-BUFFERDESC-IMMUTABLE-DYNAMIC-STREAM
  :SG-LOGITEM-VALIDATE-BUFFERDESC-SEPARATE-BUFFER-TYPES
  :SG-LOGITEM-VALIDATE-BUFFERDESC-EXPECT-NONZERO-SIZE
  :SG-LOGITEM-VALIDATE-BUFFERDESC-EXPECT-MATCHING-DATA-SIZE
  :SG-LOGITEM-VALIDATE-BUFFERDESC-EXPECT-ZERO-DATA-SIZE
  :SG-LOGITEM-VALIDATE-BUFFERDESC-EXPECT-NO-DATA
  :SG-LOGITEM-VALIDATE-BUFFERDESC-EXPECT-DATA
  :SG-LOGITEM-VALIDATE-BUFFERDESC-STORAGEBUFFER-SUPPORTED
  :SG-LOGITEM-VALIDATE-BUFFERDESC-STORAGEBUFFER-SIZE-MULTIPLE-4
  :SG-LOGITEM-VALIDATE-IMAGEDATA-NODATA
  :SG-LOGITEM-VALIDATE-IMAGEDATA-DATA-SIZE
  :SG-LOGITEM-VALIDATE-IMAGEDESC-CANARY
  :SG-LOGITEM-VALIDATE-IMAGEDESC-IMMUTABLE-DYNAMIC-STREAM
  :SG-LOGITEM-VALIDATE-IMAGEDESC-IMAGETYPE-2D-NUMSLICES
  :SG-LOGITEM-VALIDATE-IMAGEDESC-IMAGETYPE-CUBE-NUMSLICES
  :SG-LOGITEM-VALIDATE-IMAGEDESC-IMAGETYPE-ARRAY-NUMSLICES
  :SG-LOGITEM-VALIDATE-IMAGEDESC-IMAGETYPE-3D-NUMSLICES
  :SG-LOGITEM-VALIDATE-IMAGEDESC-NUMSLICES
  :SG-LOGITEM-VALIDATE-IMAGEDESC-WIDTH
  :SG-LOGITEM-VALIDATE-IMAGEDESC-HEIGHT
  :SG-LOGITEM-VALIDATE-IMAGEDESC-NONRT-PIXELFORMAT
  :SG-LOGITEM-VALIDATE-IMAGEDESC-MSAA-BUT-NO-ATTACHMENT
  :SG-LOGITEM-VALIDATE-IMAGEDESC-DEPTH-3D-IMAGE
  :SG-LOGITEM-VALIDATE-IMAGEDESC-ATTACHMENT-EXPECT-IMMUTABLE
  :SG-LOGITEM-VALIDATE-IMAGEDESC-ATTACHMENT-EXPECT-NO-DATA
  :SG-LOGITEM-VALIDATE-IMAGEDESC-ATTACHMENT-PIXELFORMAT
  :SG-LOGITEM-VALIDATE-IMAGEDESC-ATTACHMENT-RESOLVE-EXPECT-NO-MSAA
  :SG-LOGITEM-VALIDATE-IMAGEDESC-ATTACHMENT-NO-MSAA-SUPPORT
  :SG-LOGITEM-VALIDATE-IMAGEDESC-ATTACHMENT-MSAA-NUM-MIPMAPS
  :SG-LOGITEM-VALIDATE-IMAGEDESC-ATTACHMENT-MSAA-3D-IMAGE
  :SG-LOGITEM-VALIDATE-IMAGEDESC-ATTACHMENT-MSAA-CUBE-IMAGE
  :SG-LOGITEM-VALIDATE-IMAGEDESC-ATTACHMENT-MSAA-ARRAY-IMAGE
  :SG-LOGITEM-VALIDATE-IMAGEDESC-STORAGEIMAGE-PIXELFORMAT
  :SG-LOGITEM-VALIDATE-IMAGEDESC-STORAGEIMAGE-EXPECT-NO-MSAA
  :SG-LOGITEM-VALIDATE-IMAGEDESC-INJECTED-NO-DATA
  :SG-LOGITEM-VALIDATE-IMAGEDESC-DYNAMIC-NO-DATA
  :SG-LOGITEM-VALIDATE-IMAGEDESC-COMPRESSED-IMMUTABLE
  :SG-LOGITEM-VALIDATE-SAMPLERDESC-CANARY
  :SG-LOGITEM-VALIDATE-SAMPLERDESC-ANISTROPIC-REQUIRES-LINEAR-FILTERING
  :SG-LOGITEM-VALIDATE-SHADERDESC-CANARY
  :SG-LOGITEM-VALIDATE-SHADERDESC-VERTEX-SOURCE
  :SG-LOGITEM-VALIDATE-SHADERDESC-FRAGMENT-SOURCE
  :SG-LOGITEM-VALIDATE-SHADERDESC-COMPUTE-SOURCE
  :SG-LOGITEM-VALIDATE-SHADERDESC-VERTEX-SOURCE-OR-BYTECODE
  :SG-LOGITEM-VALIDATE-SHADERDESC-FRAGMENT-SOURCE-OR-BYTECODE
  :SG-LOGITEM-VALIDATE-SHADERDESC-COMPUTE-SOURCE-OR-BYTECODE
  :SG-LOGITEM-VALIDATE-SHADERDESC-INVALID-SHADER-COMBO
  :SG-LOGITEM-VALIDATE-SHADERDESC-NO-BYTECODE-SIZE
  :SG-LOGITEM-VALIDATE-SHADERDESC-METAL-THREADS-PER-THREADGROUP-INITIALIZED
  :SG-LOGITEM-VALIDATE-SHADERDESC-METAL-THREADS-PER-THREADGROUP-MULTIPLE-32
  :SG-LOGITEM-VALIDATE-SHADERDESC-UNIFORMBLOCK-NO-CONT-MEMBERS
  :SG-LOGITEM-VALIDATE-SHADERDESC-UNIFORMBLOCK-SIZE-IS-ZERO
  :SG-LOGITEM-VALIDATE-SHADERDESC-UNIFORMBLOCK-METAL-BUFFER-SLOT-COLLISION
  :SG-LOGITEM-VALIDATE-SHADERDESC-UNIFORMBLOCK-HLSL-REGISTER-B-COLLISION
  :SG-LOGITEM-VALIDATE-SHADERDESC-UNIFORMBLOCK-WGSL-GROUP0-BINDING-COLLISION
  :SG-LOGITEM-VALIDATE-SHADERDESC-UNIFORMBLOCK-SPIRV-SET0-BINDING-COLLISION
  :SG-LOGITEM-VALIDATE-SHADERDESC-UNIFORMBLOCK-NO-MEMBERS
  :SG-LOGITEM-VALIDATE-SHADERDESC-UNIFORMBLOCK-UNIFORM-GLSL-NAME
  :SG-LOGITEM-VALIDATE-SHADERDESC-UNIFORMBLOCK-SIZE-MISMATCH
  :SG-LOGITEM-VALIDATE-SHADERDESC-UNIFORMBLOCK-ARRAY-COUNT
  :SG-LOGITEM-VALIDATE-SHADERDESC-UNIFORMBLOCK-STD140-ARRAY-TYPE
  :SG-LOGITEM-VALIDATE-SHADERDESC-VIEW-STORAGEBUFFER-METAL-BUFFER-SLOT-COLLISION
  :SG-LOGITEM-VALIDATE-SHADERDESC-VIEW-STORAGEBUFFER-HLSL-REGISTER-T-COLLISION
  :SG-LOGITEM-VALIDATE-SHADERDESC-VIEW-STORAGEBUFFER-HLSL-REGISTER-U-COLLISION
  :SG-LOGITEM-VALIDATE-SHADERDESC-VIEW-STORAGEBUFFER-GLSL-BINDING-COLLISION
  :SG-LOGITEM-VALIDATE-SHADERDESC-VIEW-STORAGEBUFFER-WGSL-GROUP1-BINDING-COLLISION
  :SG-LOGITEM-VALIDATE-SHADERDESC-VIEW-STORAGEBUFFER-SPIRV-SET1-BINDING-COLLISION
  :SG-LOGITEM-VALIDATE-SHADERDESC-VIEW-STORAGEIMAGE-EXPECT-COMPUTE-STAGE
  :SG-LOGITEM-VALIDATE-SHADERDESC-VIEW-STORAGEIMAGE-METAL-TEXTURE-SLOT-COLLISION
  :SG-LOGITEM-VALIDATE-SHADERDESC-VIEW-STORAGEIMAGE-HLSL-REGISTER-U-COLLISION
  :SG-LOGITEM-VALIDATE-SHADERDESC-VIEW-STORAGEIMAGE-GLSL-BINDING-COLLISION
  :SG-LOGITEM-VALIDATE-SHADERDESC-VIEW-STORAGEIMAGE-WGSL-GROUP1-BINDING-COLLISION
  :SG-LOGITEM-VALIDATE-SHADERDESC-VIEW-STORAGEIMAGE-SPIRV-SET1-BINDING-COLLISION
  :SG-LOGITEM-VALIDATE-SHADERDESC-VIEW-TEXTURE-METAL-TEXTURE-SLOT-COLLISION
  :SG-LOGITEM-VALIDATE-SHADERDESC-VIEW-TEXTURE-HLSL-REGISTER-T-COLLISION
  :SG-LOGITEM-VALIDATE-SHADERDESC-VIEW-TEXTURE-WGSL-GROUP1-BINDING-COLLISION
  :SG-LOGITEM-VALIDATE-SHADERDESC-VIEW-TEXTURE-SPIRV-SET1-BINDING-COLLISION
  :SG-LOGITEM-VALIDATE-SHADERDESC-SAMPLER-METAL-SAMPLER-SLOT-COLLISION
  :SG-LOGITEM-VALIDATE-SHADERDESC-SAMPLER-HLSL-REGISTER-S-COLLISION
  :SG-LOGITEM-VALIDATE-SHADERDESC-SAMPLER-WGSL-GROUP1-BINDING-COLLISION
  :SG-LOGITEM-VALIDATE-SHADERDESC-SAMPLER-SPIRV-SET1-BINDING-COLLISION
  :SG-LOGITEM-VALIDATE-SHADERDESC-TEXTURE-SAMPLER-PAIR-VIEW-SLOT-OUT-OF-RANGE
  :SG-LOGITEM-VALIDATE-SHADERDESC-TEXTURE-SAMPLER-PAIR-SAMPLER-SLOT-OUT-OF-RANGE
  :SG-LOGITEM-VALIDATE-SHADERDESC-TEXTURE-SAMPLER-PAIR-TEXTURE-STAGE-MISMATCH
  :SG-LOGITEM-VALIDATE-SHADERDESC-TEXTURE-SAMPLER-PAIR-EXPECT-TEXTURE-VIEW
  :SG-LOGITEM-VALIDATE-SHADERDESC-TEXTURE-SAMPLER-PAIR-SAMPLER-STAGE-MISMATCH
  :SG-LOGITEM-VALIDATE-SHADERDESC-TEXTURE-SAMPLER-PAIR-GLSL-NAME
  :SG-LOGITEM-VALIDATE-SHADERDESC-NONFILTERING-SAMPLER-REQUIRED
  :SG-LOGITEM-VALIDATE-SHADERDESC-COMPARISON-SAMPLER-REQUIRED
  :SG-LOGITEM-VALIDATE-SHADERDESC-TEXVIEW-NOT-REFERENCED-BY-TEXTURE-SAMPLER-PAIRS
  :SG-LOGITEM-VALIDATE-SHADERDESC-SAMPLER-NOT-REFERENCED-BY-TEXTURE-SAMPLER-PAIRS
  :SG-LOGITEM-VALIDATE-SHADERDESC-ATTR-STRING-TOO-LONG
  :SG-LOGITEM-VALIDATE-PIPELINEDESC-CANARY
  :SG-LOGITEM-VALIDATE-PIPELINEDESC-SHADER
  :SG-LOGITEM-VALIDATE-PIPELINEDESC-COMPUTE-SHADER-EXPECTED
  :SG-LOGITEM-VALIDATE-PIPELINEDESC-NO-COMPUTE-SHADER-EXPECTED
  :SG-LOGITEM-VALIDATE-PIPELINEDESC-NO-CONT-ATTRS
  :SG-LOGITEM-VALIDATE-PIPELINEDESC-ATTR-BASETYPE-MISMATCH
  :SG-LOGITEM-VALIDATE-PIPELINEDESC-LAYOUT-STRIDE4
  :SG-LOGITEM-VALIDATE-PIPELINEDESC-ATTR-SEMANTICS
  :SG-LOGITEM-VALIDATE-PIPELINEDESC-SHADER-READONLY-STORAGEBUFFERS
  :SG-LOGITEM-VALIDATE-PIPELINEDESC-BLENDOP-MINMAX-REQUIRES-BLENDFACTOR-ONE
  :SG-LOGITEM-VALIDATE-VIEWDESC-CANARY
  :SG-LOGITEM-VALIDATE-VIEWDESC-UNIQUE-VIEWTYPE
  :SG-LOGITEM-VALIDATE-VIEWDESC-ANY-VIEWTYPE
  :SG-LOGITEM-VALIDATE-VIEWDESC-RESOURCE-ALIVE
  :SG-LOGITEM-VALIDATE-VIEWDESC-RESOURCE-FAILED
  :SG-LOGITEM-VALIDATE-VIEWDESC-STORAGEBUFFER-OFFSET-VS-BUFFER-SIZE
  :SG-LOGITEM-VALIDATE-VIEWDESC-STORAGEBUFFER-OFFSET-MULTIPLE-256
  :SG-LOGITEM-VALIDATE-VIEWDESC-STORAGEBUFFER-USAGE
  :SG-LOGITEM-VALIDATE-VIEWDESC-STORAGEIMAGE-USAGE
  :SG-LOGITEM-VALIDATE-VIEWDESC-COLORATTACHMENT-USAGE
  :SG-LOGITEM-VALIDATE-VIEWDESC-RESOLVEATTACHMENT-USAGE
  :SG-LOGITEM-VALIDATE-VIEWDESC-DEPTHSTENCILATTACHMENT-USAGE
  :SG-LOGITEM-VALIDATE-VIEWDESC-IMAGE-MIPLEVEL
  :SG-LOGITEM-VALIDATE-VIEWDESC-IMAGE-2D-SLICE
  :SG-LOGITEM-VALIDATE-VIEWDESC-IMAGE-CUBEMAP-SLICE
  :SG-LOGITEM-VALIDATE-VIEWDESC-IMAGE-ARRAY-SLICE
  :SG-LOGITEM-VALIDATE-VIEWDESC-IMAGE-3D-SLICE
  :SG-LOGITEM-VALIDATE-VIEWDESC-TEXTURE-EXPECT-NO-MSAA
  :SG-LOGITEM-VALIDATE-VIEWDESC-TEXTURE-MIPLEVELS
  :SG-LOGITEM-VALIDATE-VIEWDESC-TEXTURE-2D-SLICES
  :SG-LOGITEM-VALIDATE-VIEWDESC-TEXTURE-CUBEMAP-SLICES
  :SG-LOGITEM-VALIDATE-VIEWDESC-TEXTURE-ARRAY-SLICES
  :SG-LOGITEM-VALIDATE-VIEWDESC-TEXTURE-3D-SLICES
  :SG-LOGITEM-VALIDATE-VIEWDESC-STORAGEIMAGE-PIXELFORMAT
  :SG-LOGITEM-VALIDATE-VIEWDESC-COLORATTACHMENT-PIXELFORMAT
  :SG-LOGITEM-VALIDATE-VIEWDESC-DEPTHSTENCILATTACHMENT-PIXELFORMAT
  :SG-LOGITEM-VALIDATE-VIEWDESC-RESOLVEATTACHMENT-SAMPLECOUNT
  :SG-LOGITEM-VALIDATE-BEGINPASS-CANARY
  :SG-LOGITEM-VALIDATE-BEGINPASS-COMPUTEPASS-EXPECT-NO-ATTACHMENTS
  :SG-LOGITEM-VALIDATE-BEGINPASS-SWAPCHAIN-EXPECT-WIDTH
  :SG-LOGITEM-VALIDATE-BEGINPASS-SWAPCHAIN-EXPECT-WIDTH-NOTSET
  :SG-LOGITEM-VALIDATE-BEGINPASS-SWAPCHAIN-EXPECT-HEIGHT
  :SG-LOGITEM-VALIDATE-BEGINPASS-SWAPCHAIN-EXPECT-HEIGHT-NOTSET
  :SG-LOGITEM-VALIDATE-BEGINPASS-SWAPCHAIN-EXPECT-SAMPLECOUNT
  :SG-LOGITEM-VALIDATE-BEGINPASS-SWAPCHAIN-EXPECT-SAMPLECOUNT-NOTSET
  :SG-LOGITEM-VALIDATE-BEGINPASS-SWAPCHAIN-EXPECT-COLORFORMAT
  :SG-LOGITEM-VALIDATE-BEGINPASS-SWAPCHAIN-EXPECT-COLORFORMAT-NOTSET
  :SG-LOGITEM-VALIDATE-BEGINPASS-SWAPCHAIN-EXPECT-DEPTHFORMAT-NOTSET
  :SG-LOGITEM-VALIDATE-BEGINPASS-SWAPCHAIN-METAL-EXPECT-CURRENTDRAWABLE
  :SG-LOGITEM-VALIDATE-BEGINPASS-SWAPCHAIN-METAL-EXPECT-CURRENTDRAWABLE-NOTSET
  :SG-LOGITEM-VALIDATE-BEGINPASS-SWAPCHAIN-METAL-EXPECT-DEPTHSTENCILTEXTURE
  :SG-LOGITEM-VALIDATE-BEGINPASS-SWAPCHAIN-METAL-EXPECT-DEPTHSTENCILTEXTURE-NOTSET
  :SG-LOGITEM-VALIDATE-BEGINPASS-SWAPCHAIN-METAL-EXPECT-MSAACOLORTEXTURE
  :SG-LOGITEM-VALIDATE-BEGINPASS-SWAPCHAIN-METAL-EXPECT-MSAACOLORTEXTURE-NOTSET
  :SG-LOGITEM-VALIDATE-BEGINPASS-SWAPCHAIN-D3D11-EXPECT-RENDERVIEW
  :SG-LOGITEM-VALIDATE-BEGINPASS-SWAPCHAIN-D3D11-EXPECT-RENDERVIEW-NOTSET
  :SG-LOGITEM-VALIDATE-BEGINPASS-SWAPCHAIN-D3D11-EXPECT-RESOLVEVIEW
  :SG-LOGITEM-VALIDATE-BEGINPASS-SWAPCHAIN-D3D11-EXPECT-RESOLVEVIEW-NOTSET
  :SG-LOGITEM-VALIDATE-BEGINPASS-SWAPCHAIN-D3D11-EXPECT-DEPTHSTENCILVIEW
  :SG-LOGITEM-VALIDATE-BEGINPASS-SWAPCHAIN-D3D11-EXPECT-DEPTHSTENCILVIEW-NOTSET
  :SG-LOGITEM-VALIDATE-BEGINPASS-SWAPCHAIN-WGPU-EXPECT-RENDERVIEW
  :SG-LOGITEM-VALIDATE-BEGINPASS-SWAPCHAIN-WGPU-EXPECT-RENDERVIEW-NOTSET
  :SG-LOGITEM-VALIDATE-BEGINPASS-SWAPCHAIN-WGPU-EXPECT-RESOLVEVIEW
  :SG-LOGITEM-VALIDATE-BEGINPASS-SWAPCHAIN-WGPU-EXPECT-RESOLVEVIEW-NOTSET
  :SG-LOGITEM-VALIDATE-BEGINPASS-SWAPCHAIN-WGPU-EXPECT-DEPTHSTENCILVIEW
  :SG-LOGITEM-VALIDATE-BEGINPASS-SWAPCHAIN-WGPU-EXPECT-DEPTHSTENCILVIEW-NOTSET
  :SG-LOGITEM-VALIDATE-BEGINPASS-SWAPCHAIN-GL-EXPECT-FRAMEBUFFER-NOTSET
  :SG-LOGITEM-VALIDATE-BEGINPASS-COLORATTACHMENTVIEWS-CONTINUOUS
  :SG-LOGITEM-VALIDATE-BEGINPASS-COLORATTACHMENTVIEW-ALIVE
  :SG-LOGITEM-VALIDATE-BEGINPASS-COLORATTACHMENTVIEW-VALID
  :SG-LOGITEM-VALIDATE-BEGINPASS-COLORATTACHMENTVIEW-TYPE
  :SG-LOGITEM-VALIDATE-BEGINPASS-COLORATTACHMENTVIEW-IMAGE-ALIVE
  :SG-LOGITEM-VALIDATE-BEGINPASS-COLORATTACHMENTVIEW-IMAGE-VALID
  :SG-LOGITEM-VALIDATE-BEGINPASS-COLORATTACHMENTVIEW-SIZES
  :SG-LOGITEM-VALIDATE-BEGINPASS-COLORATTACHMENTVIEW-SAMPLECOUNT
  :SG-LOGITEM-VALIDATE-BEGINPASS-COLORATTACHMENTVIEW-SAMPLECOUNTS-EQUAL
  :SG-LOGITEM-VALIDATE-BEGINPASS-RESOLVEATTACHMENTVIEW-NO-COLORATTACHMENTVIEW
  :SG-LOGITEM-VALIDATE-BEGINPASS-RESOLVEATTACHMENTVIEW-ALIVE
  :SG-LOGITEM-VALIDATE-BEGINPASS-RESOLVEATTACHMENTVIEW-VALID
  :SG-LOGITEM-VALIDATE-BEGINPASS-RESOLVEATTACHMENTVIEW-TYPE
  :SG-LOGITEM-VALIDATE-BEGINPASS-RESOLVEATTACHMENTVIEW-IMAGE-ALIVE
  :SG-LOGITEM-VALIDATE-BEGINPASS-RESOLVEATTACHMENTVIEW-IMAGE-VALID
  :SG-LOGITEM-VALIDATE-BEGINPASS-RESOLVEATTACHMENTVIEW-SIZES
  :SG-LOGITEM-VALIDATE-BEGINPASS-DEPTHSTENCILATTACHMENTVIEWS-CONTINUOUS
  :SG-LOGITEM-VALIDATE-BEGINPASS-DEPTHSTENCILATTACHMENTVIEW-ALIVE
  :SG-LOGITEM-VALIDATE-BEGINPASS-DEPTHSTENCILATTACHMENTVIEW-VALID
  :SG-LOGITEM-VALIDATE-BEGINPASS-DEPTHSTENCILATTACHMENTVIEW-TYPE
  :SG-LOGITEM-VALIDATE-BEGINPASS-DEPTHSTENCILATTACHMENTVIEW-IMAGE-ALIVE
  :SG-LOGITEM-VALIDATE-BEGINPASS-DEPTHSTENCILATTACHMENTVIEW-IMAGE-VALID
  :SG-LOGITEM-VALIDATE-BEGINPASS-DEPTHSTENCILATTACHMENTVIEW-SIZES
  :SG-LOGITEM-VALIDATE-BEGINPASS-DEPTHSTENCILATTACHMENTVIEW-SAMPLECOUNT
  :SG-LOGITEM-VALIDATE-BEGINPASS-ATTACHMENTS-EXPECTED
  :SG-LOGITEM-VALIDATE-AVP-RENDERPASS-EXPECTED
  :SG-LOGITEM-VALIDATE-ASR-RENDERPASS-EXPECTED
  :SG-LOGITEM-VALIDATE-APIP-PIPELINE-VALID-ID
  :SG-LOGITEM-VALIDATE-APIP-PIPELINE-EXISTS
  :SG-LOGITEM-VALIDATE-APIP-PIPELINE-VALID
  :SG-LOGITEM-VALIDATE-APIP-PASS-EXPECTED
  :SG-LOGITEM-VALIDATE-APIP-PIPELINE-SHADER-ALIVE
  :SG-LOGITEM-VALIDATE-APIP-PIPELINE-SHADER-VALID
  :SG-LOGITEM-VALIDATE-APIP-COMPUTEPASS-EXPECTED
  :SG-LOGITEM-VALIDATE-APIP-RENDERPASS-EXPECTED
  :SG-LOGITEM-VALIDATE-APIP-SWAPCHAIN-COLOR-COUNT
  :SG-LOGITEM-VALIDATE-APIP-SWAPCHAIN-COLOR-FORMAT
  :SG-LOGITEM-VALIDATE-APIP-SWAPCHAIN-DEPTH-FORMAT
  :SG-LOGITEM-VALIDATE-APIP-SWAPCHAIN-SAMPLE-COUNT
  :SG-LOGITEM-VALIDATE-APIP-ATTACHMENTS-ALIVE
  :SG-LOGITEM-VALIDATE-APIP-COLORATTACHMENTS-COUNT
  :SG-LOGITEM-VALIDATE-APIP-COLORATTACHMENTS-VIEW-VALID
  :SG-LOGITEM-VALIDATE-APIP-COLORATTACHMENTS-IMAGE-VALID
  :SG-LOGITEM-VALIDATE-APIP-COLORATTACHMENTS-FORMAT
  :SG-LOGITEM-VALIDATE-APIP-DEPTHSTENCILATTACHMENT-VIEW-VALID
  :SG-LOGITEM-VALIDATE-APIP-DEPTHSTENCILATTACHMENT-IMAGE-VALID
  :SG-LOGITEM-VALIDATE-APIP-DEPTHSTENCILATTACHMENT-FORMAT
  :SG-LOGITEM-VALIDATE-APIP-ATTACHMENT-SAMPLE-COUNT
  :SG-LOGITEM-VALIDATE-ABND-PASS-EXPECTED
  :SG-LOGITEM-VALIDATE-ABND-EMPTY-BINDINGS
  :SG-LOGITEM-VALIDATE-ABND-NO-PIPELINE
  :SG-LOGITEM-VALIDATE-ABND-PIPELINE-ALIVE
  :SG-LOGITEM-VALIDATE-ABND-PIPELINE-VALID
  :SG-LOGITEM-VALIDATE-ABND-PIPELINE-SHADER-ALIVE
  :SG-LOGITEM-VALIDATE-ABND-PIPELINE-SHADER-VALID
  :SG-LOGITEM-VALIDATE-ABND-COMPUTE-EXPECTED-NO-VBUFS
  :SG-LOGITEM-VALIDATE-ABND-COMPUTE-EXPECTED-NO-IBUF
  :SG-LOGITEM-VALIDATE-ABND-EXPECTED-VBUF
  :SG-LOGITEM-VALIDATE-ABND-VBUF-ALIVE
  :SG-LOGITEM-VALIDATE-ABND-VBUF-USAGE
  :SG-LOGITEM-VALIDATE-ABND-VBUF-OVERFLOW
  :SG-LOGITEM-VALIDATE-ABND-EXPECTED-NO-IBUF
  :SG-LOGITEM-VALIDATE-ABND-EXPECTED-IBUF
  :SG-LOGITEM-VALIDATE-ABND-IBUF-ALIVE
  :SG-LOGITEM-VALIDATE-ABND-IBUF-USAGE
  :SG-LOGITEM-VALIDATE-ABND-IBUF-OVERFLOW
  :SG-LOGITEM-VALIDATE-ABND-EXPECTED-VIEW-BINDING
  :SG-LOGITEM-VALIDATE-ABND-VIEW-ALIVE
  :SG-LOGITEM-VALIDATE-ABND-EXPECT-TEXVIEW
  :SG-LOGITEM-VALIDATE-ABND-EXPECT-SBVIEW
  :SG-LOGITEM-VALIDATE-ABND-EXPECT-SIMGVIEW
  :SG-LOGITEM-VALIDATE-ABND-TEXVIEW-IMAGETYPE-MISMATCH
  :SG-LOGITEM-VALIDATE-ABND-TEXVIEW-EXPECTED-MULTISAMPLED-IMAGE
  :SG-LOGITEM-VALIDATE-ABND-TEXVIEW-EXPECTED-NON-MULTISAMPLED-IMAGE
  :SG-LOGITEM-VALIDATE-ABND-TEXVIEW-EXPECTED-FILTERABLE-IMAGE
  :SG-LOGITEM-VALIDATE-ABND-TEXVIEW-EXPECTED-DEPTH-IMAGE
  :SG-LOGITEM-VALIDATE-ABND-SBVIEW-READWRITE-IMMUTABLE
  :SG-LOGITEM-VALIDATE-ABND-SIMGVIEW-COMPUTE-PASS-EXPECTED
  :SG-LOGITEM-VALIDATE-ABND-SIMGVIEW-IMAGETYPE-MISMATCH
  :SG-LOGITEM-VALIDATE-ABND-SIMGVIEW-ACCESSFORMAT
  :SG-LOGITEM-VALIDATE-ABND-EXPECTED-SAMPLER-BINDING
  :SG-LOGITEM-VALIDATE-ABND-UNEXPECTED-SAMPLER-COMPARE-NEVER
  :SG-LOGITEM-VALIDATE-ABND-EXPECTED-SAMPLER-COMPARE-NEVER
  :SG-LOGITEM-VALIDATE-ABND-EXPECTED-NONFILTERING-SAMPLER
  :SG-LOGITEM-VALIDATE-ABND-SAMPLER-ALIVE
  :SG-LOGITEM-VALIDATE-ABND-SAMPLER-VALID
  :SG-LOGITEM-VALIDATE-ABND-TEXTURE-BINDING-VS-DEPTHSTENCIL-ATTACHMENT
  :SG-LOGITEM-VALIDATE-ABND-TEXTURE-BINDING-VS-COLOR-ATTACHMENT
  :SG-LOGITEM-VALIDATE-ABND-TEXTURE-BINDING-VS-RESOLVE-ATTACHMENT
  :SG-LOGITEM-VALIDATE-ABND-TEXTURE-VS-STORAGEIMAGE-BINDING
  :SG-LOGITEM-VALIDATE-AU-PASS-EXPECTED
  :SG-LOGITEM-VALIDATE-AU-NO-PIPELINE
  :SG-LOGITEM-VALIDATE-AU-PIPELINE-ALIVE
  :SG-LOGITEM-VALIDATE-AU-PIPELINE-VALID
  :SG-LOGITEM-VALIDATE-AU-PIPELINE-SHADER-ALIVE
  :SG-LOGITEM-VALIDATE-AU-PIPELINE-SHADER-VALID
  :SG-LOGITEM-VALIDATE-AU-NO-UNIFORMBLOCK-AT-SLOT
  :SG-LOGITEM-VALIDATE-AU-SIZE
  :SG-LOGITEM-VALIDATE-DRAW-RENDERPASS-EXPECTED
  :SG-LOGITEM-VALIDATE-DRAW-BASEELEMENT-GE-ZERO
  :SG-LOGITEM-VALIDATE-DRAW-NUMELEMENTS-GE-ZERO
  :SG-LOGITEM-VALIDATE-DRAW-NUMINSTANCES-GE-ZERO
  :SG-LOGITEM-VALIDATE-DRAW-EX-RENDERPASS-EXPECTED
  :SG-LOGITEM-VALIDATE-DRAW-EX-BASEELEMENT-GE-ZERO
  :SG-LOGITEM-VALIDATE-DRAW-EX-NUMELEMENTS-GE-ZERO
  :SG-LOGITEM-VALIDATE-DRAW-EX-NUMINSTANCES-GE-ZERO
  :SG-LOGITEM-VALIDATE-DRAW-EX-BASEINSTANCE-GE-ZERO
  :SG-LOGITEM-VALIDATE-DRAW-EX-BASEVERTEX-VS-INDEXED
  :SG-LOGITEM-VALIDATE-DRAW-EX-BASEINSTANCE-VS-INSTANCED
  :SG-LOGITEM-VALIDATE-DRAW-EX-BASEVERTEX-NOT-SUPPORTED
  :SG-LOGITEM-VALIDATE-DRAW-EX-BASEINSTANCE-NOT-SUPPORTED
  :SG-LOGITEM-VALIDATE-DRAW-REQUIRED-BINDINGS-OR-UNIFORMS-MISSING
  :SG-LOGITEM-VALIDATE-DISPATCH-COMPUTEPASS-EXPECTED
  :SG-LOGITEM-VALIDATE-DISPATCH-NUMGROUPSX
  :SG-LOGITEM-VALIDATE-DISPATCH-NUMGROUPSY
  :SG-LOGITEM-VALIDATE-DISPATCH-NUMGROUPSZ
  :SG-LOGITEM-VALIDATE-DISPATCH-REQUIRED-BINDINGS-OR-UNIFORMS-MISSING
  :SG-LOGITEM-VALIDATE-UPDATEBUF-USAGE
  :SG-LOGITEM-VALIDATE-UPDATEBUF-SIZE
  :SG-LOGITEM-VALIDATE-UPDATEBUF-ONCE
  :SG-LOGITEM-VALIDATE-UPDATEBUF-APPEND
  :SG-LOGITEM-VALIDATE-APPENDBUF-USAGE
  :SG-LOGITEM-VALIDATE-APPENDBUF-SIZE
  :SG-LOGITEM-VALIDATE-APPENDBUF-UPDATE
  :SG-LOGITEM-VALIDATE-UPDIMG-USAGE
  :SG-LOGITEM-VALIDATE-UPDIMG-ONCE
  :SG-LOGITEM-VALIDATION-FAILED
)

;; Structs

(cffi:defcstruct sg-buffer
  ;; sg_buffer
  (id :uint32)
)

(cffi:defcstruct sg-image
  (id :uint32)
)

(cffi:defcstruct sg-sampler
  (id :uint32)
)

(cffi:defcstruct sg-shader
  (id :uint32)
)

(cffi:defcstruct sg-pipeline
  (id :uint32)
)

(cffi:defcstruct sg-view
  (id :uint32)
)

(cffi:defcstruct sg-range
  ;; sg_range
  (ptr :pointer)
  (size :size)
)

(cffi:defcstruct sg-color
  ;; sg_color
  (r :float)
  (g :float)
  (b :float)
  (a :float)
)

(cffi:defcstruct sg-pixelformat-info
  ;; sg_pixelformat_info
  (sample :bool)
  (filter :bool)
  (render :bool)
  (blend :bool)
  (msaa :bool)
  (depth :bool)
  (compressed :bool)
  (read :bool)
  (write :bool)
  (bytes-per-pixel :int)
)

(cffi:defcstruct sg-features
  ;; sg_features
  (origin-top-left :bool)
  (image-clamp-to-border :bool)
  (mrt-independent-blend-state :bool)
  (mrt-independent-write-mask :bool)
  (compute :bool)
  (msaa-texture-bindings :bool)
  (separate-buffer-types :bool)
  (draw-base-vertex :bool)
  (draw-base-instance :bool)
  (gl-texture-views :bool)
)

(cffi:defcstruct sg-limits
  ;; sg_limits
  (max-image-size-2d :int)
  (max-image-size-cube :int)
  (max-image-size-3d :int)
  (max-image-size-array :int)
  (max-image-array-layers :int)
  (max-vertex-attrs :int)
  (max-color-attachments :int)
  (max-texture-bindings-per-stage :int)
  (max-storage-buffer-bindings-per-stage :int)
  (max-storage-image-bindings-per-stage :int)
  (gl-max-vertex-uniform-components :int)
  (gl-max-combined-texture-image-units :int)
  (d3d11-max-unordered-access-views :int)
  (vk-min-uniform-buffer-offset-alignment :int)
)

(cffi:defcstruct sg-color-attachment-action
  ;; sg_color_attachment_action
  (load-action :int)
  (store-action :int)
  (clear-value (:struct sg-color))
)

(cffi:defcstruct sg-depth-attachment-action
  (load-action :int)
  (store-action :int)
  (clear-value :float)
)

(cffi:defcstruct sg-stencil-attachment-action
  (load-action :int)
  (store-action :int)
  (clear-value :uint8)
)

(cffi:defcstruct sg-pass-action
  (colors (:struct sg-color-attachment-action) :count 8)
  (depth (:struct sg-depth-attachment-action))
  (stencil (:struct sg-stencil-attachment-action))
)

(cffi:defcstruct sg-metal-swapchain
  ;; sg_metal_swapchain
  (current-drawable :pointer)
  (depth-stencil-texture :pointer)
  (msaa-color-texture :pointer)
)

(cffi:defcstruct sg-d3d11-swapchain
  (render-view :pointer)
  (resolve-view :pointer)
  (depth-stencil-view :pointer)
)

(cffi:defcstruct sg-wgpu-swapchain
  (render-view :pointer)
  (resolve-view :pointer)
  (depth-stencil-view :pointer)
)

(cffi:defcstruct sg-vulkan-swapchain
  (render-image :pointer)
  (render-view :pointer)
  (resolve-image :pointer)
  (resolve-view :pointer)
  (depth-stencil-image :pointer)
  (depth-stencil-view :pointer)
  (render-finished-semaphore :pointer)
  (present-complete-semaphore :pointer)
)

(cffi:defcstruct sg-gl-swapchain
  (framebuffer :uint32)
)

(cffi:defcstruct sg-swapchain
  (width :int)
  (height :int)
  (sample-count :int)
  (color-format :int)
  (depth-format :int)
  (metal (:struct sg-metal-swapchain))
  (d3d11 (:struct sg-d3d11-swapchain))
  (wgpu (:struct sg-wgpu-swapchain))
  (vulkan (:struct sg-vulkan-swapchain))
  (gl (:struct sg-gl-swapchain))
)

(cffi:defcstruct sg-attachments
  ;; sg_attachments
  (colors (:struct sg-view) :count 8)
  (resolves (:struct sg-view) :count 8)
  (depth-stencil (:struct sg-view))
)

(cffi:defcstruct sg-pass
  ;; sg_pass
  (-start-canary :uint32)
  (compute :bool)
  (action (:struct sg-pass-action))
  (attachments (:struct sg-attachments))
  (swapchain (:struct sg-swapchain))
  (label :string)
  (-end-canary :uint32)
)

(cffi:defcstruct sg-bindings
  ;; sg_bindings
  (-start-canary :uint32)
  (vertex-buffers (:struct sg-buffer) :count 8)
  (vertex-buffer-offsets :int :count 8)
  (index-buffer (:struct sg-buffer))
  (index-buffer-offset :int)
  (views (:struct sg-view) :count 32)
  (samplers (:struct sg-sampler) :count 12)
  (-end-canary :uint32)
)

(cffi:defcstruct sg-buffer-usage
  ;; sg_buffer_usage
  (vertex-buffer :bool)
  (index-buffer :bool)
  (storage-buffer :bool)
  (immutable :bool)
  (dynamic-update :bool)
  (stream-update :bool)
)

(cffi:defcstruct sg-buffer-desc
  ;; sg_buffer_desc
  (-start-canary :uint32)
  (size :size)
  (usage (:struct sg-buffer-usage))
  (data (:struct sg-range))
  (label :string)
  (gl-buffers :uint32 :count 2)
  (mtl-buffers :pointer :count 2)
  (d3d11-buffer :pointer)
  (wgpu-buffer :pointer)
  (-end-canary :uint32)
)

(cffi:defcstruct sg-image-usage
  ;; sg_image_usage
  (storage-image :bool)
  (color-attachment :bool)
  (resolve-attachment :bool)
  (depth-stencil-attachment :bool)
  (immutable :bool)
  (dynamic-update :bool)
  (stream-update :bool)
)

(cffi:defcstruct sg-image-data
  ;; sg_image_data
  (mip-levels (:struct sg-range) :count 16)
)

(cffi:defcstruct sg-image-desc
  ;; sg_image_desc
  (-start-canary :uint32)
  (type :int)
  (usage (:struct sg-image-usage))
  (width :int)
  (height :int)
  (num-slices :int)
  (num-mipmaps :int)
  (pixel-format :int)
  (sample-count :int)
  (data (:struct sg-image-data))
  (label :string)
  (gl-textures :uint32 :count 2)
  (gl-texture-target :uint32)
  (mtl-textures :pointer :count 2)
  (d3d11-texture :pointer)
  (wgpu-texture :pointer)
  (-end-canary :uint32)
)

(cffi:defcstruct sg-sampler-desc
  ;; sg_sampler_desc
  (-start-canary :uint32)
  (min-filter :int)
  (mag-filter :int)
  (mipmap-filter :int)
  (wrap-u :int)
  (wrap-v :int)
  (wrap-w :int)
  (min-lod :float)
  (max-lod :float)
  (border-color :int)
  (compare :int)
  (max-anisotropy :uint32)
  (label :string)
  (gl-sampler :uint32)
  (mtl-sampler :pointer)
  (d3d11-sampler :pointer)
  (wgpu-sampler :pointer)
  (-end-canary :uint32)
)

(cffi:defcstruct sg-shader-function
  (source :string)
  (bytecode (:struct sg-range))
  (entry :string)
  (d3d11-target :string)
  (d3d11-filepath :string)
)

(cffi:defcstruct sg-shader-vertex-attr
  (base-type :int)
  (glsl-name :string)
  (hlsl-sem-name :string)
  (hlsl-sem-index :uint8)
)

(cffi:defcstruct sg-glsl-shader-uniform
  (type :int)
  (array-count :uint16)
  (glsl-name :string)
)

(cffi:defcstruct sg-shader-uniform-block
  (stage :int)
  (size :uint32)
  (hlsl-register-b-n :uint8)
  (msl-buffer-n :uint8)
  (wgsl-group0-binding-n :uint8)
  (spirv-set0-binding-n :uint8)
  (layout :int)
  (glsl-uniforms (:struct sg-glsl-shader-uniform) :count 16)
)

(cffi:defcstruct sg-shader-texture-view
  (stage :int)
  (image-type :int)
  (sample-type :int)
  (multisampled :bool)
  (hlsl-register-t-n :uint8)
  (msl-texture-n :uint8)
  (wgsl-group1-binding-n :uint8)
  (spirv-set1-binding-n :uint8)
)

(cffi:defcstruct sg-shader-storage-buffer-view
  (stage :int)
  (readonly :bool)
  (hlsl-register-t-n :uint8)
  (hlsl-register-u-n :uint8)
  (msl-buffer-n :uint8)
  (wgsl-group1-binding-n :uint8)
  (spirv-set1-binding-n :uint8)
  (glsl-binding-n :uint8)
)

(cffi:defcstruct sg-shader-storage-image-view
  (stage :int)
  (image-type :int)
  (access-format :int)
  (writeonly :bool)
  (hlsl-register-u-n :uint8)
  (msl-texture-n :uint8)
  (wgsl-group1-binding-n :uint8)
  (spirv-set1-binding-n :uint8)
  (glsl-binding-n :uint8)
)

(cffi:defcstruct sg-shader-view
  (texture (:struct sg-shader-texture-view))
  (storage-buffer (:struct sg-shader-storage-buffer-view))
  (storage-image (:struct sg-shader-storage-image-view))
)

(cffi:defcstruct sg-shader-sampler
  (stage :int)
  (sampler-type :int)
  (hlsl-register-s-n :uint8)
  (msl-sampler-n :uint8)
  (wgsl-group1-binding-n :uint8)
  (spirv-set1-binding-n :uint8)
)

(cffi:defcstruct sg-shader-texture-sampler-pair
  (stage :int)
  (view-slot :uint8)
  (sampler-slot :uint8)
  (glsl-name :string)
)

(cffi:defcstruct sg-mtl-shader-threads-per-threadgroup
  (x :int)
  (y :int)
  (z :int)
)

(cffi:defcstruct sg-shader-desc
  (-start-canary :uint32)
  (vertex-func (:struct sg-shader-function))
  (fragment-func (:struct sg-shader-function))
  (compute-func (:struct sg-shader-function))
  (attrs (:struct sg-shader-vertex-attr) :count 16)
  (uniform-blocks (:struct sg-shader-uniform-block) :count 8)
  (views (:struct sg-shader-view) :count 32)
  (samplers (:struct sg-shader-sampler) :count 12)
  (texture-sampler-pairs (:struct sg-shader-texture-sampler-pair) :count 32)
  (mtl-threads-per-threadgroup (:struct sg-mtl-shader-threads-per-threadgroup))
  (label :string)
  (-end-canary :uint32)
)

(cffi:defcstruct sg-vertex-buffer-layout-state
  ;; sg_vertex_buffer_layout_state
  (stride :int)
  (step-func :int)
  (step-rate :int)
)

(cffi:defcstruct sg-vertex-attr-state
  (buffer-index :int)
  (offset :int)
  (format :int)
)

(cffi:defcstruct sg-vertex-layout-state
  (buffers (:struct sg-vertex-buffer-layout-state) :count 8)
  (attrs (:struct sg-vertex-attr-state) :count 16)
)

(cffi:defcstruct sg-stencil-face-state
  (compare :int)
  (fail-op :int)
  (depth-fail-op :int)
  (pass-op :int)
)

(cffi:defcstruct sg-stencil-state
  (enabled :bool)
  (front (:struct sg-stencil-face-state))
  (back (:struct sg-stencil-face-state))
  (read-mask :uint8)
  (write-mask :uint8)
  (ref :uint8)
)

(cffi:defcstruct sg-depth-state
  (pixel-format :int)
  (compare :int)
  (write-enabled :bool)
  (bias :float)
  (bias-slope-scale :float)
  (bias-clamp :float)
)

(cffi:defcstruct sg-blend-state
  (enabled :bool)
  (src-factor-rgb :int)
  (dst-factor-rgb :int)
  (op-rgb :int)
  (src-factor-alpha :int)
  (dst-factor-alpha :int)
  (op-alpha :int)
)

(cffi:defcstruct sg-color-target-state
  (pixel-format :int)
  (write-mask :int)
  (blend (:struct sg-blend-state))
)

(cffi:defcstruct sg-pipeline-desc
  (-start-canary :uint32)
  (compute :bool)
  (shader (:struct sg-shader))
  (layout (:struct sg-vertex-layout-state))
  (depth (:struct sg-depth-state))
  (stencil (:struct sg-stencil-state))
  (color-count :int)
  (colors (:struct sg-color-target-state) :count 8)
  (primitive-type :int)
  (index-type :int)
  (cull-mode :int)
  (face-winding :int)
  (sample-count :int)
  (blend-color (:struct sg-color))
  (alpha-to-coverage-enabled :bool)
  (label :string)
  (-end-canary :uint32)
)

(cffi:defcstruct sg-buffer-view-desc
  ;; sg_buffer_view_desc
  (buffer (:struct sg-buffer))
  (offset :int)
)

(cffi:defcstruct sg-image-view-desc
  (image (:struct sg-image))
  (mip-level :int)
  (slice :int)
)

(cffi:defcstruct sg-texture-view-range
  (base :int)
  (count :int)
)

(cffi:defcstruct sg-texture-view-desc
  (image (:struct sg-image))
  (mip-levels (:struct sg-texture-view-range))
  (slices (:struct sg-texture-view-range))
)

(cffi:defcstruct sg-view-desc
  (-start-canary :uint32)
  (texture (:struct sg-texture-view-desc))
  (storage-buffer (:struct sg-buffer-view-desc))
  (storage-image (:struct sg-image-view-desc))
  (color-attachment (:struct sg-image-view-desc))
  (resolve-attachment (:struct sg-image-view-desc))
  (depth-stencil-attachment (:struct sg-image-view-desc))
  (label :string)
  (-end-canary :uint32)
)

(cffi:defcstruct sg-trace-hooks
  ;; sg_trace_hooks
  (user-data :pointer)
  (reset-state-cache :pointer)
  (make-buffer :pointer)
  (make-image :pointer)
  (make-sampler :pointer)
  (make-shader :pointer)
  (make-pipeline :pointer)
  (make-view :pointer)
  (destroy-buffer :pointer)
  (destroy-image :pointer)
  (destroy-sampler :pointer)
  (destroy-shader :pointer)
  (destroy-pipeline :pointer)
  (destroy-view :pointer)
  (update-buffer :pointer)
  (update-image :pointer)
  (append-buffer :pointer)
  (begin-pass :pointer)
  (apply-viewport :pointer)
  (apply-scissor-rect :pointer)
  (apply-pipeline :pointer)
  (apply-bindings :pointer)
  (apply-uniforms :pointer)
  (draw :pointer)
  (draw-ex :pointer)
  (dispatch :pointer)
  (end-pass :pointer)
  (commit :pointer)
  (alloc-buffer :pointer)
  (alloc-image :pointer)
  (alloc-sampler :pointer)
  (alloc-shader :pointer)
  (alloc-pipeline :pointer)
  (alloc-view :pointer)
  (dealloc-buffer :pointer)
  (dealloc-image :pointer)
  (dealloc-sampler :pointer)
  (dealloc-shader :pointer)
  (dealloc-pipeline :pointer)
  (dealloc-view :pointer)
  (init-buffer :pointer)
  (init-image :pointer)
  (init-sampler :pointer)
  (init-shader :pointer)
  (init-pipeline :pointer)
  (init-view :pointer)
  (uninit-buffer :pointer)
  (uninit-image :pointer)
  (uninit-sampler :pointer)
  (uninit-shader :pointer)
  (uninit-pipeline :pointer)
  (uninit-view :pointer)
  (fail-buffer :pointer)
  (fail-image :pointer)
  (fail-sampler :pointer)
  (fail-shader :pointer)
  (fail-pipeline :pointer)
  (fail-view :pointer)
  (push-debug-group :pointer)
  (pop-debug-group :pointer)
)

(cffi:defcstruct sg-slot-info
  ;; sg_slot_info
  (state :int)
  (res-id :uint32)
  (uninit-count :uint32)
)

(cffi:defcstruct sg-buffer-info
  (slot (:struct sg-slot-info))
  (update-frame-index :uint32)
  (append-frame-index :uint32)
  (append-pos :int)
  (append-overflow :bool)
  (num-slots :int)
  (active-slot :int)
)

(cffi:defcstruct sg-image-info
  (slot (:struct sg-slot-info))
  (upd-frame-index :uint32)
  (num-slots :int)
  (active-slot :int)
)

(cffi:defcstruct sg-sampler-info
  (slot (:struct sg-slot-info))
)

(cffi:defcstruct sg-shader-info
  (slot (:struct sg-slot-info))
)

(cffi:defcstruct sg-pipeline-info
  (slot (:struct sg-slot-info))
)

(cffi:defcstruct sg-view-info
  (slot (:struct sg-slot-info))
)

(cffi:defcstruct sg-frame-stats-gl
  ;; sg_frame_stats_gl
  (num-bind-buffer :uint32)
  (num-active-texture :uint32)
  (num-bind-texture :uint32)
  (num-bind-sampler :uint32)
  (num-bind-image-texture :uint32)
  (num-use-program :uint32)
  (num-render-state :uint32)
  (num-vertex-attrib-pointer :uint32)
  (num-vertex-attrib-divisor :uint32)
  (num-enable-vertex-attrib-array :uint32)
  (num-disable-vertex-attrib-array :uint32)
  (num-uniform :uint32)
  (num-memory-barriers :uint32)
)

(cffi:defcstruct sg-frame-stats-d3d11-pass
  (num-om-set-render-targets :uint32)
  (num-clear-render-target-view :uint32)
  (num-clear-depth-stencil-view :uint32)
  (num-resolve-subresource :uint32)
)

(cffi:defcstruct sg-frame-stats-d3d11-pipeline
  (num-rs-set-state :uint32)
  (num-om-set-depth-stencil-state :uint32)
  (num-om-set-blend-state :uint32)
  (num-ia-set-primitive-topology :uint32)
  (num-ia-set-input-layout :uint32)
  (num-vs-set-shader :uint32)
  (num-vs-set-constant-buffers :uint32)
  (num-ps-set-shader :uint32)
  (num-ps-set-constant-buffers :uint32)
  (num-cs-set-shader :uint32)
  (num-cs-set-constant-buffers :uint32)
)

(cffi:defcstruct sg-frame-stats-d3d11-bindings
  (num-ia-set-vertex-buffers :uint32)
  (num-ia-set-index-buffer :uint32)
  (num-vs-set-shader-resources :uint32)
  (num-vs-set-samplers :uint32)
  (num-ps-set-shader-resources :uint32)
  (num-ps-set-samplers :uint32)
  (num-cs-set-shader-resources :uint32)
  (num-cs-set-samplers :uint32)
  (num-cs-set-unordered-access-views :uint32)
)

(cffi:defcstruct sg-frame-stats-d3d11-uniforms
  (num-update-subresource :uint32)
)

(cffi:defcstruct sg-frame-stats-d3d11-draw
  (num-draw-indexed-instanced :uint32)
  (num-draw-indexed :uint32)
  (num-draw-instanced :uint32)
  (num-draw :uint32)
)

(cffi:defcstruct sg-frame-stats-d3d11
  (pass (:struct sg-frame-stats-d3d11-pass))
  (pipeline (:struct sg-frame-stats-d3d11-pipeline))
  (bindings (:struct sg-frame-stats-d3d11-bindings))
  (uniforms (:struct sg-frame-stats-d3d11-uniforms))
  (draw (:struct sg-frame-stats-d3d11-draw))
  (num-map :uint32)
  (num-unmap :uint32)
)

(cffi:defcstruct sg-frame-stats-metal-idpool
  (num-added :uint32)
  (num-released :uint32)
  (num-garbage-collected :uint32)
)

(cffi:defcstruct sg-frame-stats-metal-pipeline
  (num-set-blend-color :uint32)
  (num-set-cull-mode :uint32)
  (num-set-front-facing-winding :uint32)
  (num-set-stencil-reference-value :uint32)
  (num-set-depth-bias :uint32)
  (num-set-render-pipeline-state :uint32)
  (num-set-depth-stencil-state :uint32)
)

(cffi:defcstruct sg-frame-stats-metal-bindings
  (num-set-vertex-buffer :uint32)
  (num-set-vertex-buffer-offset :uint32)
  (num-skip-redundant-vertex-buffer :uint32)
  (num-set-vertex-texture :uint32)
  (num-skip-redundant-vertex-texture :uint32)
  (num-set-vertex-sampler-state :uint32)
  (num-skip-redundant-vertex-sampler-state :uint32)
  (num-set-fragment-buffer :uint32)
  (num-set-fragment-buffer-offset :uint32)
  (num-skip-redundant-fragment-buffer :uint32)
  (num-set-fragment-texture :uint32)
  (num-skip-redundant-fragment-texture :uint32)
  (num-set-fragment-sampler-state :uint32)
  (num-skip-redundant-fragment-sampler-state :uint32)
  (num-set-compute-buffer :uint32)
  (num-set-compute-buffer-offset :uint32)
  (num-skip-redundant-compute-buffer :uint32)
  (num-set-compute-texture :uint32)
  (num-skip-redundant-compute-texture :uint32)
  (num-set-compute-sampler-state :uint32)
  (num-skip-redundant-compute-sampler-state :uint32)
)

(cffi:defcstruct sg-frame-stats-metal-uniforms
  (num-set-vertex-buffer-offset :uint32)
  (num-set-fragment-buffer-offset :uint32)
  (num-set-compute-buffer-offset :uint32)
)

(cffi:defcstruct sg-frame-stats-metal
  (idpool (:struct sg-frame-stats-metal-idpool))
  (pipeline (:struct sg-frame-stats-metal-pipeline))
  (bindings (:struct sg-frame-stats-metal-bindings))
  (uniforms (:struct sg-frame-stats-metal-uniforms))
)

(cffi:defcstruct sg-frame-stats-wgpu-uniforms
  (num-set-bindgroup :uint32)
  (size-write-buffer :uint32)
)

(cffi:defcstruct sg-frame-stats-wgpu-bindings
  (num-set-vertex-buffer :uint32)
  (num-skip-redundant-vertex-buffer :uint32)
  (num-set-index-buffer :uint32)
  (num-skip-redundant-index-buffer :uint32)
  (num-create-bindgroup :uint32)
  (num-discard-bindgroup :uint32)
  (num-set-bindgroup :uint32)
  (num-skip-redundant-bindgroup :uint32)
  (num-bindgroup-cache-hits :uint32)
  (num-bindgroup-cache-misses :uint32)
  (num-bindgroup-cache-collisions :uint32)
  (num-bindgroup-cache-invalidates :uint32)
  (num-bindgroup-cache-hash-vs-key-mismatch :uint32)
)

(cffi:defcstruct sg-frame-stats-wgpu
  (uniforms (:struct sg-frame-stats-wgpu-uniforms))
  (bindings (:struct sg-frame-stats-wgpu-bindings))
)

(cffi:defcstruct sg-frame-stats-vk
  (num-cmd-pipeline-barrier :uint32)
  (num-allocate-memory :uint32)
  (num-free-memory :uint32)
  (size-allocate-memory :uint32)
  (num-delete-queue-added :uint32)
  (num-delete-queue-collected :uint32)
  (num-cmd-copy-buffer :uint32)
  (num-cmd-copy-buffer-to-image :uint32)
  (num-cmd-set-descriptor-buffer-offsets :uint32)
  (size-descriptor-buffer-writes :uint32)
)

(cffi:defcstruct sg-frame-resource-stats
  (allocated :uint32)
  (deallocated :uint32)
  (inited :uint32)
  (uninited :uint32)
)

(cffi:defcstruct sg-total-resource-stats
  (alive :uint32)
  (free :uint32)
  (allocated :uint32)
  (deallocated :uint32)
  (inited :uint32)
  (uninited :uint32)
)

(cffi:defcstruct sg-total-stats
  (buffers (:struct sg-total-resource-stats))
  (images (:struct sg-total-resource-stats))
  (samplers (:struct sg-total-resource-stats))
  (views (:struct sg-total-resource-stats))
  (shaders (:struct sg-total-resource-stats))
  (pipelines (:struct sg-total-resource-stats))
)

(cffi:defcstruct sg-frame-stats
  (frame-index :uint32)
  (num-passes :uint32)
  (num-apply-viewport :uint32)
  (num-apply-scissor-rect :uint32)
  (num-apply-pipeline :uint32)
  (num-apply-bindings :uint32)
  (num-apply-uniforms :uint32)
  (num-draw :uint32)
  (num-draw-ex :uint32)
  (num-dispatch :uint32)
  (num-update-buffer :uint32)
  (num-append-buffer :uint32)
  (num-update-image :uint32)
  (size-apply-uniforms :uint32)
  (size-update-buffer :uint32)
  (size-append-buffer :uint32)
  (size-update-image :uint32)
  (buffers (:struct sg-frame-resource-stats))
  (images (:struct sg-frame-resource-stats))
  (samplers (:struct sg-frame-resource-stats))
  (views (:struct sg-frame-resource-stats))
  (shaders (:struct sg-frame-resource-stats))
  (pipelines (:struct sg-frame-resource-stats))
  (gl (:struct sg-frame-stats-gl))
  (d3d11 (:struct sg-frame-stats-d3d11))
  (metal (:struct sg-frame-stats-metal))
  (wgpu (:struct sg-frame-stats-wgpu))
  (vk (:struct sg-frame-stats-vk))
)

(cffi:defcstruct sg-stats
  (prev-frame (:struct sg-frame-stats))
  (cur-frame (:struct sg-frame-stats))
  (total (:struct sg-total-stats))
)

(cffi:defcstruct sg-environment-defaults
  ;; sg_environment_defaults
  (color-format :int)
  (depth-format :int)
  (sample-count :int)
)

(cffi:defcstruct sg-metal-environment
  (device :pointer)
)

(cffi:defcstruct sg-d3d11-environment
  (device :pointer)
  (device-context :pointer)
)

(cffi:defcstruct sg-wgpu-environment
  (device :pointer)
)

(cffi:defcstruct sg-vulkan-environment
  (physical-device :pointer)
  (device :pointer)
  (queue :pointer)
  (queue-family-index :uint32)
)

(cffi:defcstruct sg-environment
  (defaults (:struct sg-environment-defaults))
  (metal (:struct sg-metal-environment))
  (d3d11 (:struct sg-d3d11-environment))
  (wgpu (:struct sg-wgpu-environment))
  (vulkan (:struct sg-vulkan-environment))
)

(cffi:defcstruct sg-commit-listener
  ;; sg_commit_listener
  (func :pointer)
  (user-data :pointer)
)

(cffi:defcstruct sg-allocator
  ;; sg_allocator
  (alloc-fn :pointer)
  (free-fn :pointer)
  (user-data :pointer)
)

(cffi:defcstruct sg-logger
  ;; sg_logger
  (func :pointer)
  (user-data :pointer)
)

(cffi:defcstruct sg-d3d11-desc
  (shader-debugging :bool)
)

(cffi:defcstruct sg-metal-desc
  (force-managed-storage-mode :bool)
  (use-command-buffer-with-retained-references :bool)
)

(cffi:defcstruct sg-wgpu-desc
  (disable-bindgroups-cache :bool)
  (bindgroups-cache-size :int)
)

(cffi:defcstruct sg-vulkan-desc
  (copy-staging-buffer-size :int)
  (stream-staging-buffer-size :int)
  (descriptor-buffer-size :int)
)

(cffi:defcstruct sg-desc
  (-start-canary :uint32)
  (buffer-pool-size :int)
  (image-pool-size :int)
  (sampler-pool-size :int)
  (shader-pool-size :int)
  (pipeline-pool-size :int)
  (view-pool-size :int)
  (uniform-buffer-size :int)
  (max-commit-listeners :int)
  (disable-validation :bool)
  (enforce-portable-limits :bool)
  (d3d11 (:struct sg-d3d11-desc))
  (metal (:struct sg-metal-desc))
  (wgpu (:struct sg-wgpu-desc))
  (vulkan (:struct sg-vulkan-desc))
  (allocator (:struct sg-allocator))
  (logger (:struct sg-logger))
  (environment (:struct sg-environment))
  (-end-canary :uint32)
)

(cffi:defcstruct sg-d3d11-buffer-info
  ;; sg_d3d11_buffer_info
  (buf :pointer)
)

(cffi:defcstruct sg-d3d11-image-info
  (tex2d :pointer)
  (tex3d :pointer)
  (res :pointer)
)

(cffi:defcstruct sg-d3d11-sampler-info
  (smp :pointer)
)

(cffi:defcstruct sg-d3d11-shader-info
  (cbufs :pointer :count 8)
  (vs :pointer)
  (fs :pointer)
)

(cffi:defcstruct sg-d3d11-pipeline-info
  (il :pointer)
  (rs :pointer)
  (dss :pointer)
  (bs :pointer)
)

(cffi:defcstruct sg-d3d11-view-info
  (srv :pointer)
  (uav :pointer)
  (rtv :pointer)
  (dsv :pointer)
)

(cffi:defcstruct sg-mtl-buffer-info
  (buf :pointer :count 2)
  (active-slot :int)
)

(cffi:defcstruct sg-mtl-image-info
  (tex :pointer :count 2)
  (active-slot :int)
)

(cffi:defcstruct sg-mtl-sampler-info
  (smp :pointer)
)

(cffi:defcstruct sg-mtl-shader-info
  (vertex-lib :pointer)
  (fragment-lib :pointer)
  (vertex-func :pointer)
  (fragment-func :pointer)
)

(cffi:defcstruct sg-mtl-pipeline-info
  (rps :pointer)
  (dss :pointer)
)

(cffi:defcstruct sg-wgpu-buffer-info
  (buf :pointer)
)

(cffi:defcstruct sg-wgpu-image-info
  (tex :pointer)
)

(cffi:defcstruct sg-wgpu-sampler-info
  (smp :pointer)
)

(cffi:defcstruct sg-wgpu-shader-info
  (vs-mod :pointer)
  (fs-mod :pointer)
  (bgl :pointer)
)

(cffi:defcstruct sg-wgpu-pipeline-info
  (render-pipeline :pointer)
  (compute-pipeline :pointer)
)

(cffi:defcstruct sg-wgpu-view-info
  (view :pointer)
)

(cffi:defcstruct sg-gl-buffer-info
  (buf :uint32 :count 2)
  (active-slot :int)
)

(cffi:defcstruct sg-gl-image-info
  (tex :uint32 :count 2)
  (tex-target :uint32)
  (active-slot :int)
)

(cffi:defcstruct sg-gl-sampler-info
  (smp :uint32)
)

(cffi:defcstruct sg-gl-shader-info
  (prog :uint32)
)

(cffi:defcstruct sg-gl-view-info
  (tex-view :uint32 :count 2)
  (msaa-render-buffer :uint32)
  (msaa-resolve-frame-buffer :uint32)
)

;; Functions

(cffi:defcfun ("sg_setup" sg-setup) :void
  ;; sg_setup
  (desc (:pointer (:struct sg-desc)))
)

(cffi:defcfun ("sg_shutdown" sg-shutdown) :void
)

(cffi:defcfun ("sg_isvalid" sg-isvalid) :bool
)

(cffi:defcfun ("sg_reset_state_cache" sg-reset-state-cache) :void
)

(cffi:defcfun ("sg_install_trace_hooks" sg-install-trace-hooks) (:struct sg-trace-hooks)
  (trace-hooks (:pointer (:struct sg-trace-hooks)))
)

(cffi:defcfun ("sg_push_debug_group" sg-push-debug-group) :void
  (name :string)
)

(cffi:defcfun ("sg_pop_debug_group" sg-pop-debug-group) :void
)

(cffi:defcfun ("sg_add_commit_listener" sg-add-commit-listener) :bool
  (listener (:struct sg-commit-listener))
)

(cffi:defcfun ("sg_remove_commit_listener" sg-remove-commit-listener) :bool
  (listener (:struct sg-commit-listener))
)

(cffi:defcfun ("sg_make_buffer" sg-make-buffer) (:struct sg-buffer)
  ;; sg_make_buffer
  (desc (:pointer (:struct sg-buffer-desc)))
)

(cffi:defcfun ("sg_make_image" sg-make-image) (:struct sg-image)
  (desc (:pointer (:struct sg-image-desc)))
)

(cffi:defcfun ("sg_make_sampler" sg-make-sampler) (:struct sg-sampler)
  (desc (:pointer (:struct sg-sampler-desc)))
)

(cffi:defcfun ("sg_make_shader" sg-make-shader) (:struct sg-shader)
  (desc (:pointer (:struct sg-shader-desc)))
)

(cffi:defcfun ("sg_make_pipeline" sg-make-pipeline) (:struct sg-pipeline)
  (desc (:pointer (:struct sg-pipeline-desc)))
)

(cffi:defcfun ("sg_make_view" sg-make-view) (:struct sg-view)
  (desc (:pointer (:struct sg-view-desc)))
)

(cffi:defcfun ("sg_destroy_buffer" sg-destroy-buffer) :void
  (buf (:struct sg-buffer))
)

(cffi:defcfun ("sg_destroy_image" sg-destroy-image) :void
  (img (:struct sg-image))
)

(cffi:defcfun ("sg_destroy_sampler" sg-destroy-sampler) :void
  (smp (:struct sg-sampler))
)

(cffi:defcfun ("sg_destroy_shader" sg-destroy-shader) :void
  (shd (:struct sg-shader))
)

(cffi:defcfun ("sg_destroy_pipeline" sg-destroy-pipeline) :void
  (pip (:struct sg-pipeline))
)

(cffi:defcfun ("sg_destroy_view" sg-destroy-view) :void
  (view (:struct sg-view))
)

(cffi:defcfun ("sg_update_buffer" sg-update-buffer) :void
  (buf (:struct sg-buffer))
  (data (:pointer (:struct sg-range)))
)

(cffi:defcfun ("sg_update_image" sg-update-image) :void
  (img (:struct sg-image))
  (data (:pointer (:struct sg-image-data)))
)

(cffi:defcfun ("sg_append_buffer" sg-append-buffer) :int
  (buf (:struct sg-buffer))
  (data (:pointer (:struct sg-range)))
)

(cffi:defcfun ("sg_query_buffer_overflow" sg-query-buffer-overflow) :bool
  (buf (:struct sg-buffer))
)

(cffi:defcfun ("sg_query_buffer_will_overflow" sg-query-buffer-will-overflow) :bool
  (buf (:struct sg-buffer))
  (size :size)
)

(cffi:defcfun ("sg_begin_pass" sg-begin-pass) :void
  ;; sg_begin_pass
  (pass (:pointer (:struct sg-pass)))
)

(cffi:defcfun ("sg_apply_viewport" sg-apply-viewport) :void
  (x :int)
  (y :int)
  (width :int)
  (height :int)
  (origin-top-left :bool)
)

(cffi:defcfun ("sg_apply_viewportf" sg-apply-viewportf) :void
  (x :float)
  (y :float)
  (width :float)
  (height :float)
  (origin-top-left :bool)
)

(cffi:defcfun ("sg_apply_scissor_rect" sg-apply-scissor-rect) :void
  (x :int)
  (y :int)
  (width :int)
  (height :int)
  (origin-top-left :bool)
)

(cffi:defcfun ("sg_apply_scissor_rectf" sg-apply-scissor-rectf) :void
  (x :float)
  (y :float)
  (width :float)
  (height :float)
  (origin-top-left :bool)
)

(cffi:defcfun ("sg_apply_pipeline" sg-apply-pipeline) :void
  (pip (:struct sg-pipeline))
)

(cffi:defcfun ("sg_apply_bindings" sg-apply-bindings) :void
  (bindings (:pointer (:struct sg-bindings)))
)

(cffi:defcfun ("sg_apply_uniforms" sg-apply-uniforms) :void
  (ub-slot :int)
  (data (:pointer (:struct sg-range)))
)

(cffi:defcfun ("sg_draw" sg-draw) :void
  (base-element :int)
  (num-elements :int)
  (num-instances :int)
)

(cffi:defcfun ("sg_draw_ex" sg-draw-ex) :void
  (base-element :int)
  (num-elements :int)
  (num-instances :int)
  (base-vertex :int)
  (base-instance :int)
)

(cffi:defcfun ("sg_dispatch" sg-dispatch) :void
  (num-groups-x :int)
  (num-groups-y :int)
  (num-groups-z :int)
)

(cffi:defcfun ("sg_end_pass" sg-end-pass) :void
)

(cffi:defcfun ("sg_commit" sg-commit) :void
)

(cffi:defcfun ("sg_query_desc" sg-query-desc) (:struct sg-desc)
  ;; sg_query_desc
)

(cffi:defcfun ("sg_query_backend" sg-query-backend) :int
)

(cffi:defcfun ("sg_query_features" sg-query-features) (:struct sg-features)
)

(cffi:defcfun ("sg_query_limits" sg-query-limits) (:struct sg-limits)
)

(cffi:defcfun ("sg_query_pixelformat" sg-query-pixelformat) (:struct sg-pixelformat-info)
  (fmt :int)
)

(cffi:defcfun ("sg_query_row_pitch" sg-query-row-pitch) :int
  (fmt :int)
  (width :int)
  (row-align-bytes :int)
)

(cffi:defcfun ("sg_query_surface_pitch" sg-query-surface-pitch) :int
  (fmt :int)
  (width :int)
  (height :int)
  (row-align-bytes :int)
)

(cffi:defcfun ("sg_query_buffer_state" sg-query-buffer-state) :int
  ;; sg_query_buffer_state
  (buf (:struct sg-buffer))
)

(cffi:defcfun ("sg_query_image_state" sg-query-image-state) :int
  (img (:struct sg-image))
)

(cffi:defcfun ("sg_query_sampler_state" sg-query-sampler-state) :int
  (smp (:struct sg-sampler))
)

(cffi:defcfun ("sg_query_shader_state" sg-query-shader-state) :int
  (shd (:struct sg-shader))
)

(cffi:defcfun ("sg_query_pipeline_state" sg-query-pipeline-state) :int
  (pip (:struct sg-pipeline))
)

(cffi:defcfun ("sg_query_view_state" sg-query-view-state) :int
  (view (:struct sg-view))
)

(cffi:defcfun ("sg_query_buffer_info" sg-query-buffer-info) (:struct sg-buffer-info)
  ;; sg_query_buffer_info
  (buf (:struct sg-buffer))
)

(cffi:defcfun ("sg_query_image_info" sg-query-image-info) (:struct sg-image-info)
  (img (:struct sg-image))
)

(cffi:defcfun ("sg_query_sampler_info" sg-query-sampler-info) (:struct sg-sampler-info)
  (smp (:struct sg-sampler))
)

(cffi:defcfun ("sg_query_shader_info" sg-query-shader-info) (:struct sg-shader-info)
  (shd (:struct sg-shader))
)

(cffi:defcfun ("sg_query_pipeline_info" sg-query-pipeline-info) (:struct sg-pipeline-info)
  (pip (:struct sg-pipeline))
)

(cffi:defcfun ("sg_query_view_info" sg-query-view-info) (:struct sg-view-info)
  (view (:struct sg-view))
)

(cffi:defcfun ("sg_query_buffer_desc" sg-query-buffer-desc) (:struct sg-buffer-desc)
  ;; sg_query_buffer_desc
  (buf (:struct sg-buffer))
)

(cffi:defcfun ("sg_query_image_desc" sg-query-image-desc) (:struct sg-image-desc)
  (img (:struct sg-image))
)

(cffi:defcfun ("sg_query_sampler_desc" sg-query-sampler-desc) (:struct sg-sampler-desc)
  (smp (:struct sg-sampler))
)

(cffi:defcfun ("sg_query_shader_desc" sg-query-shader-desc) (:struct sg-shader-desc)
  (shd (:struct sg-shader))
)

(cffi:defcfun ("sg_query_pipeline_desc" sg-query-pipeline-desc) (:struct sg-pipeline-desc)
  (pip (:struct sg-pipeline))
)

(cffi:defcfun ("sg_query_view_desc" sg-query-view-desc) (:struct sg-view-desc)
  (view (:struct sg-view))
)

(cffi:defcfun ("sg_query_buffer_defaults" sg-query-buffer-defaults) (:struct sg-buffer-desc)
  ;; sg_query_buffer_defaults
  (desc (:pointer (:struct sg-buffer-desc)))
)

(cffi:defcfun ("sg_query_image_defaults" sg-query-image-defaults) (:struct sg-image-desc)
  (desc (:pointer (:struct sg-image-desc)))
)

(cffi:defcfun ("sg_query_sampler_defaults" sg-query-sampler-defaults) (:struct sg-sampler-desc)
  (desc (:pointer (:struct sg-sampler-desc)))
)

(cffi:defcfun ("sg_query_shader_defaults" sg-query-shader-defaults) (:struct sg-shader-desc)
  (desc (:pointer (:struct sg-shader-desc)))
)

(cffi:defcfun ("sg_query_pipeline_defaults" sg-query-pipeline-defaults) (:struct sg-pipeline-desc)
  (desc (:pointer (:struct sg-pipeline-desc)))
)

(cffi:defcfun ("sg_query_view_defaults" sg-query-view-defaults) (:struct sg-view-desc)
  (desc (:pointer (:struct sg-view-desc)))
)

(cffi:defcfun ("sg_query_buffer_size" sg-query-buffer-size) :size
  ;; sg_query_buffer_size
  (buf (:struct sg-buffer))
)

(cffi:defcfun ("sg_query_buffer_usage" sg-query-buffer-usage) (:struct sg-buffer-usage)
  (buf (:struct sg-buffer))
)

(cffi:defcfun ("sg_query_image_type" sg-query-image-type) :int
  (img (:struct sg-image))
)

(cffi:defcfun ("sg_query_image_width" sg-query-image-width) :int
  (img (:struct sg-image))
)

(cffi:defcfun ("sg_query_image_height" sg-query-image-height) :int
  (img (:struct sg-image))
)

(cffi:defcfun ("sg_query_image_num_slices" sg-query-image-num-slices) :int
  (img (:struct sg-image))
)

(cffi:defcfun ("sg_query_image_num_mipmaps" sg-query-image-num-mipmaps) :int
  (img (:struct sg-image))
)

(cffi:defcfun ("sg_query_image_pixelformat" sg-query-image-pixelformat) :int
  (img (:struct sg-image))
)

(cffi:defcfun ("sg_query_image_usage" sg-query-image-usage) (:struct sg-image-usage)
  (img (:struct sg-image))
)

(cffi:defcfun ("sg_query_image_sample_count" sg-query-image-sample-count) :int
  (img (:struct sg-image))
)

(cffi:defcfun ("sg_query_view_type" sg-query-view-type) :int
  (view (:struct sg-view))
)

(cffi:defcfun ("sg_query_view_image" sg-query-view-image) (:struct sg-image)
  (view (:struct sg-view))
)

(cffi:defcfun ("sg_query_view_buffer" sg-query-view-buffer) (:struct sg-buffer)
  (view (:struct sg-view))
)

(cffi:defcfun ("sg_alloc_buffer" sg-alloc-buffer) (:struct sg-buffer)
  ;; sg_alloc_buffer
)

(cffi:defcfun ("sg_alloc_image" sg-alloc-image) (:struct sg-image)
)

(cffi:defcfun ("sg_alloc_sampler" sg-alloc-sampler) (:struct sg-sampler)
)

(cffi:defcfun ("sg_alloc_shader" sg-alloc-shader) (:struct sg-shader)
)

(cffi:defcfun ("sg_alloc_pipeline" sg-alloc-pipeline) (:struct sg-pipeline)
)

(cffi:defcfun ("sg_alloc_view" sg-alloc-view) (:struct sg-view)
)

(cffi:defcfun ("sg_dealloc_buffer" sg-dealloc-buffer) :void
  (buf (:struct sg-buffer))
)

(cffi:defcfun ("sg_dealloc_image" sg-dealloc-image) :void
  (img (:struct sg-image))
)

(cffi:defcfun ("sg_dealloc_sampler" sg-dealloc-sampler) :void
  (smp (:struct sg-sampler))
)

(cffi:defcfun ("sg_dealloc_shader" sg-dealloc-shader) :void
  (shd (:struct sg-shader))
)

(cffi:defcfun ("sg_dealloc_pipeline" sg-dealloc-pipeline) :void
  (pip (:struct sg-pipeline))
)

(cffi:defcfun ("sg_dealloc_view" sg-dealloc-view) :void
  (view (:struct sg-view))
)

(cffi:defcfun ("sg_init_buffer" sg-init-buffer) :void
  (buf (:struct sg-buffer))
  (desc (:pointer (:struct sg-buffer-desc)))
)

(cffi:defcfun ("sg_init_image" sg-init-image) :void
  (img (:struct sg-image))
  (desc (:pointer (:struct sg-image-desc)))
)

(cffi:defcfun ("sg_init_sampler" sg-init-sampler) :void
  (smg (:struct sg-sampler))
  (desc (:pointer (:struct sg-sampler-desc)))
)

(cffi:defcfun ("sg_init_shader" sg-init-shader) :void
  (shd (:struct sg-shader))
  (desc (:pointer (:struct sg-shader-desc)))
)

(cffi:defcfun ("sg_init_pipeline" sg-init-pipeline) :void
  (pip (:struct sg-pipeline))
  (desc (:pointer (:struct sg-pipeline-desc)))
)

(cffi:defcfun ("sg_init_view" sg-init-view) :void
  (view (:struct sg-view))
  (desc (:pointer (:struct sg-view-desc)))
)

(cffi:defcfun ("sg_uninit_buffer" sg-uninit-buffer) :void
  (buf (:struct sg-buffer))
)

(cffi:defcfun ("sg_uninit_image" sg-uninit-image) :void
  (img (:struct sg-image))
)

(cffi:defcfun ("sg_uninit_sampler" sg-uninit-sampler) :void
  (smp (:struct sg-sampler))
)

(cffi:defcfun ("sg_uninit_shader" sg-uninit-shader) :void
  (shd (:struct sg-shader))
)

(cffi:defcfun ("sg_uninit_pipeline" sg-uninit-pipeline) :void
  (pip (:struct sg-pipeline))
)

(cffi:defcfun ("sg_uninit_view" sg-uninit-view) :void
  (view (:struct sg-view))
)

(cffi:defcfun ("sg_fail_buffer" sg-fail-buffer) :void
  (buf (:struct sg-buffer))
)

(cffi:defcfun ("sg_fail_image" sg-fail-image) :void
  (img (:struct sg-image))
)

(cffi:defcfun ("sg_fail_sampler" sg-fail-sampler) :void
  (smp (:struct sg-sampler))
)

(cffi:defcfun ("sg_fail_shader" sg-fail-shader) :void
  (shd (:struct sg-shader))
)

(cffi:defcfun ("sg_fail_pipeline" sg-fail-pipeline) :void
  (pip (:struct sg-pipeline))
)

(cffi:defcfun ("sg_fail_view" sg-fail-view) :void
  (view (:struct sg-view))
)

(cffi:defcfun ("sg_enable_stats" sg-enable-stats) :void
  ;; sg_enable_stats
)

(cffi:defcfun ("sg_disable_stats" sg-disable-stats) :void
)

(cffi:defcfun ("sg_stats_enabled" sg-stats-enabled) :bool
)

(cffi:defcfun ("sg_query_stats" sg-query-stats) (:struct sg-stats)
)

(cffi:defcfun ("sg_d3d11_device" sg-d3d11-device) :pointer
  ;; sg_d3d11_device
)

(cffi:defcfun ("sg_d3d11_device_context" sg-d3d11-device-context) :pointer
  ;; sg_d3d11_device_context
)

(cffi:defcfun ("sg_d3d11_query_buffer_info" sg-d3d11-query-buffer-info) (:struct sg-d3d11-buffer-info)
  ;; sg_d3d11_query_buffer_info
  (buf (:struct sg-buffer))
)

(cffi:defcfun ("sg_d3d11_query_image_info" sg-d3d11-query-image-info) (:struct sg-d3d11-image-info)
  ;; sg_d3d11_query_image_info
  (img (:struct sg-image))
)

(cffi:defcfun ("sg_d3d11_query_sampler_info" sg-d3d11-query-sampler-info) (:struct sg-d3d11-sampler-info)
  ;; sg_d3d11_query_sampler_info
  (smp (:struct sg-sampler))
)

(cffi:defcfun ("sg_d3d11_query_shader_info" sg-d3d11-query-shader-info) (:struct sg-d3d11-shader-info)
  ;; sg_d3d11_query_shader_info
  (shd (:struct sg-shader))
)

(cffi:defcfun ("sg_d3d11_query_pipeline_info" sg-d3d11-query-pipeline-info) (:struct sg-d3d11-pipeline-info)
  ;; sg_d3d11_query_pipeline_info
  (pip (:struct sg-pipeline))
)

(cffi:defcfun ("sg_d3d11_query_view_info" sg-d3d11-query-view-info) (:struct sg-d3d11-view-info)
  ;; sg_d3d11_query_view_info
  (view (:struct sg-view))
)

(cffi:defcfun ("sg_mtl_device" sg-mtl-device) :pointer
  ;; sg_mtl_device
)

(cffi:defcfun ("sg_mtl_render_command_encoder" sg-mtl-render-command-encoder) :pointer
  ;; sg_mtl_render_command_encoder
)

(cffi:defcfun ("sg_mtl_compute_command_encoder" sg-mtl-compute-command-encoder) :pointer
  ;; sg_mtl_compute_command_encoder
)

(cffi:defcfun ("sg_mtl_query_buffer_info" sg-mtl-query-buffer-info) (:struct sg-mtl-buffer-info)
  ;; sg_mtl_query_buffer_info
  (buf (:struct sg-buffer))
)

(cffi:defcfun ("sg_mtl_query_image_info" sg-mtl-query-image-info) (:struct sg-mtl-image-info)
  ;; sg_mtl_query_image_info
  (img (:struct sg-image))
)

(cffi:defcfun ("sg_mtl_query_sampler_info" sg-mtl-query-sampler-info) (:struct sg-mtl-sampler-info)
  ;; sg_mtl_query_sampler_info
  (smp (:struct sg-sampler))
)

(cffi:defcfun ("sg_mtl_query_shader_info" sg-mtl-query-shader-info) (:struct sg-mtl-shader-info)
  ;; sg_mtl_query_shader_info
  (shd (:struct sg-shader))
)

(cffi:defcfun ("sg_mtl_query_pipeline_info" sg-mtl-query-pipeline-info) (:struct sg-mtl-pipeline-info)
  ;; sg_mtl_query_pipeline_info
  (pip (:struct sg-pipeline))
)

(cffi:defcfun ("sg_wgpu_device" sg-wgpu-device) :pointer
  ;; sg_wgpu_device
)

(cffi:defcfun ("sg_wgpu_queue" sg-wgpu-queue) :pointer
  ;; sg_wgpu_queue
)

(cffi:defcfun ("sg_wgpu_command_encoder" sg-wgpu-command-encoder) :pointer
  ;; sg_wgpu_command_encoder
)

(cffi:defcfun ("sg_wgpu_render_pass_encoder" sg-wgpu-render-pass-encoder) :pointer
  ;; sg_wgpu_render_pass_encoder
)

(cffi:defcfun ("sg_wgpu_compute_pass_encoder" sg-wgpu-compute-pass-encoder) :pointer
  ;; sg_wgpu_compute_pass_encoder
)

(cffi:defcfun ("sg_wgpu_query_buffer_info" sg-wgpu-query-buffer-info) (:struct sg-wgpu-buffer-info)
  ;; sg_wgpu_query_buffer_info
  (buf (:struct sg-buffer))
)

(cffi:defcfun ("sg_wgpu_query_image_info" sg-wgpu-query-image-info) (:struct sg-wgpu-image-info)
  ;; sg_wgpu_query_image_info
  (img (:struct sg-image))
)

(cffi:defcfun ("sg_wgpu_query_sampler_info" sg-wgpu-query-sampler-info) (:struct sg-wgpu-sampler-info)
  ;; sg_wgpu_query_sampler_info
  (smp (:struct sg-sampler))
)

(cffi:defcfun ("sg_wgpu_query_shader_info" sg-wgpu-query-shader-info) (:struct sg-wgpu-shader-info)
  ;; sg_wgpu_query_shader_info
  (shd (:struct sg-shader))
)

(cffi:defcfun ("sg_wgpu_query_pipeline_info" sg-wgpu-query-pipeline-info) (:struct sg-wgpu-pipeline-info)
  ;; sg_wgpu_query_pipeline_info
  (pip (:struct sg-pipeline))
)

(cffi:defcfun ("sg_wgpu_query_view_info" sg-wgpu-query-view-info) (:struct sg-wgpu-view-info)
  ;; sg_wgpu_query_view_info
  (view (:struct sg-view))
)

(cffi:defcfun ("sg_gl_query_buffer_info" sg-gl-query-buffer-info) (:struct sg-gl-buffer-info)
  ;; sg_gl_query_buffer_info
  (buf (:struct sg-buffer))
)

(cffi:defcfun ("sg_gl_query_image_info" sg-gl-query-image-info) (:struct sg-gl-image-info)
  ;; sg_gl_query_image_info
  (img (:struct sg-image))
)

(cffi:defcfun ("sg_gl_query_sampler_info" sg-gl-query-sampler-info) (:struct sg-gl-sampler-info)
  ;; sg_gl_query_sampler_info
  (smp (:struct sg-sampler))
)

(cffi:defcfun ("sg_gl_query_shader_info" sg-gl-query-shader-info) (:struct sg-gl-shader-info)
  ;; sg_gl_query_shader_info
  (shd (:struct sg-shader))
)

(cffi:defcfun ("sg_gl_query_view_info" sg-gl-query-view-info) (:struct sg-gl-view-info)
  ;; sg_gl_query_view_info
  (view (:struct sg-view))
)

